
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../04%20%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BA%8B%E5%8A%A1%E8%B7%AF%E7%94%B1/">
      
      
        <link rel="next" href="../06%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.7">
    
    
      
        <title>第二部分 Part Two：Transaction Layer 事务层 - 杰森的KBA</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.4b4a2bd9.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#part-twotransaction-layer" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="杰森的KBA" class="md-header__button md-logo" aria-label="杰森的KBA" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            杰森的KBA
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第二部分    Part Two：Transaction Layer 事务层
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_3" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9h-1.9M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69m-9.15 3.96h2.3L12 9l-1.15 3.65Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_3">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jasonchu24/kba" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jasonchu24/kba
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  Welcome to MkDocs

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../blog/" class="md-tabs__link">
          
  
    
  
  Blog

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../hardware/async_sram.en/" class="md-tabs__link">
          
  
    
  
  Hardware

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../01%20%E8%83%8C%E6%99%AF/" class="md-tabs__link">
          
  
    
  
  Pcie

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../software/atomic_instructions/" class="md-tabs__link">
          
  
    
  
  Software

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="杰森的KBA" class="md-nav__button md-logo" aria-label="杰森的KBA" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    杰森的KBA
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jasonchu24/kba" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jasonchu24/kba
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Welcome to MkDocs
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../blog/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Blog
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
    
    
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    归档
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            归档
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../blog/archive/2023/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2023
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    分类
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            分类
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../blog/category/blog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blog
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Hardware
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Hardware
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/async_sram.en/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Asynchronous SRAM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/async_sram.zh/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    异步 SRAM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/bus_protocol/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    总线协议
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/cache_coherence_protocol/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    缓存一致性协议
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/cmos/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CMOS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/display_interface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    显示接口
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/error_detection_correction_code/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    检错纠错码
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/high_speed_serial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高速串行通信
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/i2c/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    I2C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/logic_levels.en/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Logic level standards
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/logic_levels.zh/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    逻辑电平标准
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/on_chip_networks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    片上网络
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/ooo_cpu/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    乱序执行 CPU
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/oscillator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    振荡器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/pcie/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PCIe
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/sdram.en/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SDRAM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/sdram.zh/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SDRAM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../hardware/spi/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SPI
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Pcie
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Pcie
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../01%20%E8%83%8C%E6%99%AF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    01 背景
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../02%20PCIe%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    02 PCIe 体系结构概述
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../03%20PCIe%20%E9%85%8D%E7%BD%AE%E6%A6%82%E8%BF%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    03 PCIe 配置概述
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../04%20%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BA%8B%E5%8A%A1%E8%B7%AF%E7%94%B1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    04 地址空间与事务路由
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    第二部分    Part Two：Transaction Layer 事务层
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    第二部分    Part Two：Transaction Layer 事务层
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-5-tlp-element-tlp" class="md-nav__link">
    Chapter 5      TLP Element //TLP 元素
  </a>
  
    <nav class="md-nav" aria-label="Chapter 5 TLP Element //TLP 元素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    关于上一章
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    关于本章
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    关于下一章
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#51-introduction-to-packet-based-protocol" class="md-nav__link">
    5.1 基于数据包协议的介绍（Introduction to Packet-Based Protocol）
  </a>
  
    <nav class="md-nav" aria-label="5.1 基于数据包协议的介绍（Introduction to Packet-Based Protocol）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#511-general" class="md-nav__link">
    5.1.1     概括（General）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#512" class="md-nav__link">
    5.1.2     使用基于数据包协议的动机
  </a>
  
    <nav class="md-nav" aria-label="5.1.2 使用基于数据包协议的动机">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#5121" class="md-nav__link">
    5.1.2.1   精心定义的数据包格式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5122" class="md-nav__link">
    5.1.2.2   使用组帧符号定义包的边界
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5123-crc" class="md-nav__link">
    5.1.2.3   使用 CRC 保障整个数据包的正确传输
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-tlp-tlp-details" class="md-nav__link">
    5.2 TLP 细节（TLP Details）
  </a>
  
    <nav class="md-nav" aria-label="5.2 TLP 细节（TLP Details）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521-tlp" class="md-nav__link">
    5.2.1     TLP 的组包和拆包
  </a>
  
    <nav class="md-nav" aria-label="5.2.1 TLP 的组包和拆包">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    发送方
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    接收方
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522-tlp" class="md-nav__link">
    5.2.2     TLP 结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#523-tlp-header-generic-tlp-header-format" class="md-nav__link">
    5.2.3     通用 TLP Header 格式（Generic TLP Header Format）
  </a>
  
    <nav class="md-nav" aria-label="5.2.3 通用 TLP Header 格式（Generic TLP Header Format）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#5231-general" class="md-nav__link">
    5.2.3.1   概括（General）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5232-header" class="md-nav__link">
    5.2.3.2   通用 Header 各字段摘要
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#524-tlp-header-generic-tlp-header-details" class="md-nav__link">
    5.2.4     通用 TLP Header 详细说明（Generic TLP Header Details）
  </a>
  
    <nav class="md-nav" aria-label="5.2.4 通用 TLP Header 详细说明（Generic TLP Header Details）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#5241-header-typeformat" class="md-nav__link">
    5.2.4.1   Header 的 Type/Format 字段编码含义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5242-digestecrc" class="md-nav__link">
    5.2.4.2   Digest/ECRC 字段
  </a>
  
    <nav class="md-nav" aria-label="5.2.4.2 Digest/ECRC 字段">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-ecrc" class="md-nav__link">
    l ECRC 的生成和检查
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-ecrc_1" class="md-nav__link">
    l 谁来检查 ECRC
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5243-using-byte-enables" class="md-nav__link">
    5.2.4.3   使用字节使能（Using Byte Enables）
  </a>
  
    <nav class="md-nav" aria-label="5.2.4.3 使用字节使能（Using Byte Enables）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l" class="md-nav__link">
    l 整体说明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l_1" class="md-nav__link">
    l 字节使能规则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l_2" class="md-nav__link">
    l 字节使能示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5244-transaction-descriptor-fields" class="md-nav__link">
    5.2.4.4   事务描述符字段（Transaction Descriptor Fields）
  </a>
  
    <nav class="md-nav" aria-label="5.2.4.4 事务描述符字段（Transaction Descriptor Fields）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-idtransaction-id" class="md-nav__link">
    l 事务 ID（Transaction ID）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-traffic-class" class="md-nav__link">
    l 流量类型（Traffic Class）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-transaction-attributes" class="md-nav__link">
    l 事务属性（Transaction Attributes）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5245-tlp" class="md-nav__link">
    5.2.4.5   带有数据荷载的 TLP 的一些额外规则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#525-tlp-tlp-tlp" class="md-nav__link">
    5.2.5     具体的 TLP 格式：请求 TLP 和完成 TLP
  </a>
  
    <nav class="md-nav" aria-label="5.2.5 具体的 TLP 格式：请求 TLP 和完成 TLP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#5251-io-io-request" class="md-nav__link">
    5.2.5.1   IO 请求（IO Request）
  </a>
  
    <nav class="md-nav" aria-label="5.2.5.1 IO 请求（IO Request）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-io-request-header" class="md-nav__link">
    l IO Request Header 的格式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-io-request-header_1" class="md-nav__link">
    l IO Request Header 各字段
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5252-memory-memory-request" class="md-nav__link">
    5.2.5.2   Memory 请求（Memory Request）
  </a>
  
    <nav class="md-nav" aria-label="5.2.5.2 Memory 请求（Memory Request）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-memory-request-header" class="md-nav__link">
    l Memory Request Header 各字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-memory-request" class="md-nav__link">
    l Memory Request 注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5253-configuration-configuration-request" class="md-nav__link">
    5.2.5.3   Configuration 请求（Configuration Request）
  </a>
  
    <nav class="md-nav" aria-label="5.2.5.3 Configuration 请求（Configuration Request）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-configuration-request-header" class="md-nav__link">
    l Configuration Request Header 各字段的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-configuration-request" class="md-nav__link">
    l Configuration Request 注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5254-completion" class="md-nav__link">
    5.2.5.4   完成包（Completion）
  </a>
  
    <nav class="md-nav" aria-label="5.2.5.4 完成包（Completion）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-completion-header" class="md-nav__link">
    l Completion Header 各字段的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-summary-of-completion-status-codes" class="md-nav__link">
    l 完成包状态码总结（Summary of Completion Status Codes）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-calculating-the-lower-address-field" class="md-nav__link">
    l 计算低位地址字段（Calculating the Lower Address Field）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-using-the-byte-count-modified-bit" class="md-nav__link">
    l 使用字节数修改位（Using The Byte Count Modified Bit）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-data-returned-for-read-requests" class="md-nav__link">
    l 读请求数据返回（Data Returned For Read Requests）:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-receiver-completion-handling-rules" class="md-nav__link">
    l 接收者对完成包的处理规则（Receiver Completion Handling Rules）:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5255-message-requests" class="md-nav__link">
    5.2.5.5   消息请求（Message Requests）
  </a>
  
    <nav class="md-nav" aria-label="5.2.5.5 消息请求（Message Requests）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l-message-header-message-request-header-fields" class="md-nav__link">
    l Message 请求 Header 各字段（Message Request Header Fields）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-message-using-the-byte-count-modified-bit" class="md-nav__link">
    l Message 注意事项（Using The Byte Count Modified Bit）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-intx-messageintx-interrupt-messages" class="md-nav__link">
    l INTx 中断 Message（INTx Interrupt Messages）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-messagepower-management-messages" class="md-nav__link">
    l 电源管理 Message（Power Management Messages）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-messageerror-messages" class="md-nav__link">
    l 错误 Message（Error Messages）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-locked-transaction-support" class="md-nav__link">
    l 支持锁定事务（Locked Transaction Support）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-messageset-slot-power-limit-message" class="md-nav__link">
    l 设置插槽功率限制 Message（Set Slot Power Limit Message）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-message-0-1vendor-defined-message-0-and-1" class="md-nav__link">
    l 厂商定义的 Message 0 和 1（Vendor-Defined Message 0 and 1）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-messageignored-message" class="md-nav__link">
    l 被忽略的Message（Ignored Message）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-messagelatency-tolerance-reporting-message" class="md-nav__link">
    l 延迟容忍报告Message（Latency Tolerance Reporting Message）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#l-buffer-messageoptimized-buffer-flush-and-fill" class="md-nav__link">
    l 优化的Buffer 刷新和填充Message（Optimized Buffer Flush and Fill）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../06%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    06 流量控制
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../07%20QoS%20%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    07 QoS 服务质量
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../08%20%E4%BA%8B%E5%8A%A1%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    08 事务排序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09%20DLLP%20%E5%85%83%E7%B4%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chpater 9 DLLP Element// DLLP 元素
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../12%20%E7%89%A9%E7%90%86%E5%B1%82%E9%80%BB%E8%BE%91%28gen3%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chpater 12 Physical Layer - Logical(Gen3)//物理层逻辑（Gen3）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../14%20%E9%93%BE%E8%B7%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%AE%AD%E7%BB%83/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chpater 14 Link Initialization & Training//链路初始化与训练
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../all/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    All
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Software
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Software
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/atomic_instructions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    原子指令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/cg/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    计算机图形学
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/cpio/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpio 文件格式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/dijkstra/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dijkstra 算法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/gcc/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GCC Internals
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/tar/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tar 文件格式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../software/transformer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="part-twotransaction-layer">第二部分    Part Two：Transaction Layer 事务层<a class="headerlink" href="#part-twotransaction-layer" title="Permanent link">&para;</a></h1>
<h2 id="chapter-5-tlp-element-tlp">Chapter 5      TLP Element //TLP 元素<a class="headerlink" href="#chapter-5-tlp-element-tlp" title="Permanent link">&para;</a></h2>
<h3 id="_1">关于上一章<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>上一章描述了一个 Function 通过 BARs 请求地址空间（内存地址空间或 IO 地址空间）的目的和方法，还描述了软件如何配置 Bridge 的 Base/Limit 寄存器，将源端口的 TLP 路由至正确的目的端口。我们还讨论了 PCIe 中 TLP 路由的一般概念，包括基于地址的路由、基于 ID 的路由，以及隐式路由（implicit routing）。</p>
<h3 id="_2">关于本章<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>在 PCIe 设备之间，信息是以包的形式进行传输的，包主要分为三类：TLP（Transaction Layer Packet，事务层包）、DLLP（Data Link Layer Packet，数据链路层包）和 Ordered Set（命令集，它应用于物理层）。本章将讲述 TLP 的用法、格式和不同种类的定义，并将详细讲解 TLP 的相关字段含义。关于 DLLP 的内容将会在 Chapter 9 “DLLP Element” 中进行单独讲解。</p>
<h3 id="_3">关于下一章<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>下一章将讨论流量控制协议（Flow Control Protocol）的目的和详细操作。流量控制是用来确保发送方在接收方无法接收 TLP 时，不再继续发送 TLP。流量控制避免了接收缓存的溢出，也消除了原本 PCI 工作方式中的一些低效行为，比如断开（disconnect）、重试（retry）和等待态（wait-state）。</p>
<h3 id="51-introduction-to-packet-based-protocol">5.1 基于数据包协议的介绍（Introduction to Packet-Based Protocol）<a class="headerlink" href="#51-introduction-to-packet-based-protocol" title="Permanent link">&para;</a></h3>
<h4 id="511-general">5.1.1     概括（General）<a class="headerlink" href="#511-general" title="Permanent link">&para;</a></h4>
<p>不同于并行总线，PCIe 这样的串行总线不使用总线上的控制信号来表示某时刻链路上正在发生什么。相反地，PCIe 链路上的发送方发出的比特流必须要有一个预期的大小，还要有一个可供接收方辨认的格式，这样接收方才能理解比特流的内容。此外，PCIe 在传输数据包时并不使用任何直接握手机制（immediate handshake）。</p>
<p>除了逻辑空闲符号（Logical Idle symbol）和 Ordered Set 的物理层包外，在活跃的 PCIe 链路上传输的信息的基本组块被称为 Packet（包），包是由符号组成的。链路上交换的两类主要的数据包为高层的 TLP（Transaction Layer Packet，事务层包），和低层的用于链路维护的包称为 DLLP（Data Link Layer Packet，数据链路层包）。这些包和它们的传输流如图 5‑1 所示。物理层的 Ordered Set 也是一种包，但是它并不像 TLP 和 DLLP 一样会被封装上包起始符号和包结束符号（也就是前面章节所讲的组帧符号），并且 Ordered Set 也并没有像 TLP 和 DLLP 一样的字节条带化过程，相反地，Ordered Set 会在链路的每个通道（lane）上都复制一份，而不是像字节条带化一样把信息按字节分配到各个通道上。</p>
<p><img alt="image-20220502163039798" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/image-20220502163039798.png" /></p>
<p>图 5‑1 TLP 和 DLLP 包</p>
<h4 id="512">5.1.2     使用基于数据包协议的动机<a class="headerlink" href="#512" title="Permanent link">&para;</a></h4>
<p>使用基于包的协议（Packet-Based Protocol）有三个明显的优点，特别是对于数据完整性（data integrity）来说：</p>
<h5 id="5121">5.1.2.1   精心定义的数据包格式<a class="headerlink" href="#5121" title="Permanent link">&para;</a></h5>
<p>像 PCI 这种早期的总线，它们允许总线上不确定数据量大小的传输，这使得只要传输没有结束就无法识别出数据荷载（payload）的边界。此外，任何一个设备都可以在此次传输完成前终止这个传输，这使得发送方很难去计算并传输一个覆盖了整个数据荷载的校验和或者 CRC。相反地，PCI 使用了一种简单的奇偶校验的方案，并在每个数据阶段（data phase）进行奇偶校验。（这里如果没理解请参阅 Chapter 1 内的 PCI 相关内容）</p>
<p>相比之下，PCIe 包具有一个已知的大小和格式。位于包的开头的部分为 Header，它用来指示这个包的类型，并包含了必需字段（required field）和可选字段（optional field）。除了地址字段以外，Header 中的其他字段长度都是固定的，地址字段可以为 32bit 也可以为 64bit。一旦一次传输开始，接收方不能暂停或者提前终止它。这种结构化的格式使得我们可以在 TLP 中加入一些信息来更有利于进行可靠的传输，例如加入组帧符号（framing symbol）、CRC、以及一个包的序列号（Sequence Number）。</p>
<h5 id="5122">5.1.2.2   使用组帧符号定义包的边界<a class="headerlink" href="#5122" title="Permanent link">&para;</a></h5>
<p>在 PCIe Gen1 和 Gen2 操作模式中使用的是 8b/10b 编码，因此在这 Gen1 和 Gen2 中每个 TLP 和 DLLP 在发送前都会使用起始符号（Start）和结束符号（End）这两种控制符号来进行组帧，这样就可以给接收方清晰地定义出包的边界。这是在 PCI 和 PCI-X 上的重大改进，在 PCI 和 PCI-X 中使用一个单独的 FRAME# 信号来指示一个事务的开始和结束，如果 FRAME# 出现了毛刺，或者其他的控制信号出现了毛刺，那么都有可能造成目标设备对总线行为的误解。一个 PCIe 接收方必须在最后的链路活动开始或结束之前，就正确完成一个完整 10bit 符号的译码，这样接收方能更容易识别不期望出现或者无法识别的符号，并且将其作为一个错误来处理。</p>
<p>对于 PCIe Gen3 使用的 128b/130b 编码来说，控制字符不再被使用，并且也没有组帧符号了。对于更多的关于 Gen3 编码与早期版本的差异的内容，请参阅 Chapter 12“Physical Layer-Logical（Gen3）”。</p>
<h5 id="5123-crc">5.1.2.3   使用 CRC 保障整个数据包的正确传输<a class="headerlink" href="#5123-crc" title="Permanent link">&para;</a></h5>
<p>在 PCI 体系结构中，会在地址阶段（address phase）和数据阶段（data phase）中使用奇偶校验边带（side-band）信号，但是在 PCIe 中则不同。PCIe 中使用带内（in-band）的 CRC 值来验证整个数据包是否进行了无错误的传输。同时 TLP 还会被发送方的数据链路层添加上一个序列号（Sequence Number），这使得当这个序列号的数据包传输出错时可以很简单的定位到它，并进行自动的重传。发送方会在自己的 Retry Buffer 内保存每个 TLP 的一个副本，直到接收方确认了这个 TLP 成功无错传输后才会将副本清除。这种 TLP 的确认机制被称为 Ack/Nak 协议（更多内容请参阅 Chapter 10 “Ack/Nak Protocol” ），它用来形成基础的链路级 TLP 错误检测和纠正机制。这种 Ack/Nak 协议提供的错误恢复机制使得我们可以在问题发生的地方或者链路上及时的解决问题，但是这也要求有一个本地的硬件解决方案来支持这种协议。</p>
<h3 id="52-tlp-tlp-details">5.2 TLP 细节（TLP Details）<a class="headerlink" href="#52-tlp-tlp-details" title="Permanent link">&para;</a></h3>
<p>在 PCIe 中，高层次事务起源于发送方的 Device Core，终止于接收方的 Device Core。事务层会处理这些请求，其中，发送端的事务层组装 TLP，接收端的事务层解析 TLP。在这个过程中，每个设备的数据链路层和物理层也会参与包的组装。</p>
<h4 id="521-tlp">5.2.1     TLP 的组包和拆包<a class="headerlink" href="#521-tlp" title="Permanent link">&para;</a></h4>
<p>如图 5‑2 所示的是链路的发送端组装 TLP 和接收端拆解 TLP 的一般流程。现在让我们讲一讲从一个包的生成，到它被传送到接收端的 Device Core 的各个步骤。下面列出了 TLP 组包和拆包的关键阶段，列出的编号与图 5‑2 中的编号相对应。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image212.jpg" /></p>
<p>图 5‑2 PCIe TLP 的组包与拆包</p>
<h5 id="_4">发送方<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h5>
<ol>
<li>
<p>设备 A 的 Device Core 向它的 PCIe 接口发送一个请求（具体 Device Core 是如何给 PCIe 接口发送请求的，这并不是 PCIe 协议或者本书的讨论范畴）。这个请求中包括：</p>
</li>
<li>
<p>目标地址或者 ID（也就是路由信息）</p>
</li>
<li>源端信息，例如 Requester ID 和 Tag</li>
<li>事务类型/数据包类型（需要执行的命令，例如一个内存读取 MRd）</li>
<li>
<p>数据荷载大小 payload size 和数据荷载内容（如果 TLP 需要带数据）</p>
</li>
<li>
<p>流量类型（Traffic Class，用于分配数据包的优先级）</p>
</li>
<li>
<p>请求的自身属性（No Snoop 无窥探、Relaxed Ordering 宽松排序，等等）</p>
</li>
<li>
<p>基于这个请求，事务层将会组建 TLP Header，并在其后附上数据荷载（如果有），以及如果启用并支持可选项的话也可以再附上 ECRC（End-to-End CRC）。随后 TLP 就会被放入一个虚拟通道 Buffer。这个虚拟通道会根据事务排序规则来管理 TLP 的顺序，并在向下转发 TLP 到数据链路层之前，确认接收方有足够的 Buffer 来接收一个 TLP。</p>
</li>
<li>
<p>当 TLP 到达数据链路层，它会被分配一个序列号（Sequence Number），并基于 TLP 的内容和序列号来计算出一个 LCRC（Link CRC）来附加在原 TLP 后。然后会将经过这些处理过程之后的 TLP 保存一个副本，这个副本会保存在数据链路层的重传 Buffer（Replay Buffer，也可称为 Retry Buffer）中，这是为了应对传输出错的情况。与此同时，这个 TLP 也会被向下转发至物理层。</p>
</li>
<li>
<p>物理层将会进行一系列的操作来准备对这个数据包进行串行传输，包括字节条带化（Byte Striping）、扰码（Scrambling）、编码（Encoding）以及并串转换（Serializing）。对于 Gen1 和 Gen2 的设备，当进行 8b/10b 编码时，会将 STP 和 END 这两个控制字符分别加在 TLP 的首端和尾端。最后，这个数据包通过链路进行传输。在 Gen3 操作模式中，STP 令牌（STP token）会被添加在 TLP 的首端，但是并不会在尾端加上 END，而是在 STP 令牌中包含 TLP 大小的信息来判断 TLP 的尾部位置。</p>
</li>
</ol>
<h5 id="_5">接收方<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h5>
<ol>
<li>
<p>在接收方（本例中是 Device B），为了发送包所做的一切准备现在都必须撤销。物理层将对比特流进行串并转换（deserialize）、对串并转换后的符号进行解码，然后再进行字节反条带化（un-stripes）。控制字符将被移除，因为它们仅在物理层有意义，然后这个数据包就会被向上转发至数据链路层。</p>
</li>
<li>
<p>数据链路层将会计算 CRC（具体一点是 LCRC）并与 TLP 中的 CRC 进行比较。如果 CRC 比较结果相同，那么就再检查序列号（Sequence Number）。如果都没有出现错误，那就把 CRC 和序列号都从 TLP 剥除，并随后将 TLP 向上转发给接收方事务层，与此同时要通过返回给发送方一个 Ack DLLP 来通知发送方这个 TLP 被成功接收。相反地，如果前面的过程中检查出了错误，那么就要返回给发送方一个 Nak DLLP，这样发送方将会使用它的重传 Buffer 来对 TLP 进行重传。</p>
</li>
<li>
<p>在事务层，TLP 被进行解码，并将 TLP 内的信息传递给 Device Core 来进行相应的操作。如果当前接收设备就是数据包的最终目的地，那么它可以检查 ECRC 错误，并在发现任何 ECRC 错误时报告给 Device Core。</p>
</li>
</ol>
<h4 id="522-tlp">5.2.2     TLP 结构<a class="headerlink" href="#522-tlp" title="Permanent link">&para;</a></h4>
<p>一个事务层包 TLP 中每个字段域的基本用法在表 5‑1 中进行了定义。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image214.jpg" /></p>
<p>表 5‑1 TLP Header 的 Type 字段定义了事务不同种类</p>
<p>下面对表 5‑1 中的内容进行复述。</p>
<ul>
<li>
<p>Header</p>
</li>
<li>
<p>协议层次：事务层</p>
</li>
<li>
<p>该组件用法：大小为 3 或 4DW（12 或 16Bytes）。Header 的格式会随类型而变化，但是 Header 也定义了一些参数，包括：</p>
<ul>
<li>
<p>事务类型（Transaction Type）</p>
</li>
<li>
<p>目标地址、ID 等</p>
</li>
<li>
<p>传输数据量大小（如果有数据）、字节使能（Byte Enable）</p>
</li>
<li>
<p>属性（Attribute）</p>
</li>
<li>
<p>流量类型（Traffic Class）</p>
</li>
</ul>
</li>
<li>
<p>Data</p>
</li>
<li>
<p>协议层次：事务层</p>
</li>
<li>
<p>该组件用法：可选的 1-1024DW 大小的数据荷载，具体的大小由字节使能或者字节对齐的开始和结束地址来进行描述。需要注意指定的长度不能为 0，但是一个 0 长度的读取可以通过指定长度为 1DW 然后将字节使能全部置为 0 来进行近似处理（在某些情况下会使用）。来自 Completer 的结果数据虽然是未定义的种类，但是 Requester 并不使用它，因此就和指定 0 长度的目的等效了。</p>
</li>
<li>
<p>Digest/ECRC</p>
</li>
<li>
<p>协议层次：事务层</p>
</li>
<li>
<p>该组件用法：可选的功能。当需要使用时，ECRC 的大小永远为 1DW。</p>
</li>
</ul>
<h4 id="523-tlp-header-generic-tlp-header-format">5.2.3     通用 TLP Header 格式（Generic TLP Header Format）<a class="headerlink" href="#523-tlp-header-generic-tlp-header-format" title="Permanent link">&para;</a></h4>
<h5 id="5231-general">5.2.3.1   概括（General）<a class="headerlink" href="#5231-general" title="Permanent link">&para;</a></h5>
<p>如图 5‑3 中，展示了一个 4DW 的通用 TLP Header 的格式和内容。在本节内，会对几乎所有事务的 TLP Header 中的公共字段进行总结，并会在稍后讨论与特定事务类型相关 Header 格式差异。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image216.jpg" /></p>
<p>图 5‑3 通用 TLP Header 的各字段域</p>
<h5 id="5232-header">5.2.3.2   通用 Header 各字段摘要<a class="headerlink" href="#5232-header" title="Permanent link">&para;</a></h5>
<p>表 5‑2 中对通用 TLP Header 中的每个字段的大小和用途进行了总结。需要注意的是，在图 5‑3 中被标注为“R”的字段是保留字段（reserve），应该被置为 0。</p>
<table>
<thead>
<tr>
<th>Header 中的字段名</th>
<th>Header 中的位置</th>
<th>字段作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  (Format)</td>
<td>Byte  0  Bit  7:5</td>
<td>这些 bit 的编码信息是关于 Header 的大小，以及这个 TLP 中是否存在数据荷载部分： <br> 000b：3DW Header，无数据荷载 <br> 001b：4DW Header，无数据荷载 <br> 010b：3DW Header，有数据荷载 <br> 011b：4DW Header，有数据荷载 <br> 100b：1DW，属于 Prefix TLP  不难发现，除了 Prefix TLP 外，只要 Fmt[0]=0 那么就是 3DW Header，反之则为 4DW Header。若 Fmt[1]=0 那么就无数据荷载，反之则有数据荷载。  对于低于 4GB 的地址，必须使用 3DW Header。协议规定，如果使用 4DW Header 但是地址小于 4GB，也就是说将 64bit 地址的高 32bit 置为 0，那么这种情况下接收方的行为是未进行定义的（undefined）。</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0  Bit  4:0</td>
<td>这些 bit 编码的信息是 TLP 的不同事务类型。Type 字段用来跟 Fmt[1:0]字段一起指定了事务类型、Header 大小、以及是否存在数据荷载。更多详细信息请参阅“Generic Header  Field Details”一节。</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  (Traffic  Class)</td>
<td>Byte  1  Bit  6:4</td>
<td>这些 bit 表示将应用于这个 TLP 和与之完成相关（如果需要完成包）的流量类型： <br> 000b：Traffic Class  0（默认） <br> 001b：Traffic Class  1  …… <br> 111b：Traffic Class  7  TC 0 是默认类型，而 TC 1-7 是用来提供差异化的服务。更多信息请参阅“Traffic Class”一节。</td>
</tr>
<tr>
<td>Attr[2]  属性  (Attribute)</td>
<td>Byte  1  Bit  2</td>
<td>这个第三位的 Attribute 位（它共有 3 位）用于表示这个 TLP 是否使用基于 ID 的排序（ID-based Ordering）。更多内容请参阅“ID Based Ordering”一节。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  (TLP  Processing Hints)</td>
<td>Byte  1  Bit  0</td>
<td>它用于表示何时 TLP 中会包含 TLP 提示（TLP Hints），以便让系统了解如何更好的处理这个 TLP。更多内容请参阅“TPH（TLP Processing Hints）”。</td>
</tr>
<tr>
<td>TD  TLP 摘要  (TLP  Digest)</td>
<td>Byte  2  Bit  7</td>
<td>如果 TD=1，那么这个 TLP 中将包括可选的 4Byte TLP Digest 字段，也就是 ECRC 值。  它有一些规则： <br> 所有的接收者都必须要通过这个 bit 来检查是否存在 Digest 字段。 <br> 如果一个 TLP 的 TD=1，但是它又没有 Digest，那么它将被当做畸形 TLP（Malformed TLP）处理。 <br> 如果接收设备支持 ECRC 校验，且此 TLP 内 TD=1，那么这个接收设备必须进行校验。 <br> 如果一个作为 TLP 最终目的地的设备并不支持 ECRC 校验（因为这是可选功能），那么它必须要忽略 Digest 字段。  更多内容请参阅“CRC”和“ECRC Generating and Checking”这两节。</td>
</tr>
<tr>
<td>EP  受污染的数据  (Poisoned Data)</td>
<td>Byte 2  Bit 6</td>
<td>如果 EP=1，那么就认为所有伴随此数据的数据都是无效的，尽管相关事务依然允许正常的完成。关于 Poisoned 数据包的更多内容，请参阅“Data Poisoning”一节。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  (Attributes)</td>
<td>Byte  2  Bit  5:4</td>
<td>Bit 5 = Relax Ordering（宽松排序）：当它被置为 1 时，这个 TLP 会启用 PCI-X 的宽松排序。如果它为 0，则是用 PCI 的严格的 PCI 排序（strict PCI ordering）。  Bit 4 = No Snoop（无窥探）：当置为 1 时，Requester 的意思是这个 TLP 不会存在 host cache 一致性的问题（host cache coherency issues），因此系统硬件可以通过跳过普通处理器对这个请求的 cache 窥探，以此来节省时间。而当这一位被置为 0 时，需要进行 PCI-type 的 cache 窥探保护。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  (Address  Type)</td>
<td>Byte  2  Bit  3:2</td>
<td>对于 Memory 和 Atomic 请求来说，这个字段用于支持虚拟化系统（virtualized system）的地址转换。这个地址转换协议由一个单独的规范进行描述，被称为 Address  Translation Services，可以看到该字段的编码为： <br> 00 = 默认/未转换（Default/Untranslated） <br> 01 = 转换请求（Translation Request） <br> 10 = 已转换（Translated） <br> 11 = 保留 reserve</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2  Bit  1:0     Byte  3  Bit  7:0</td>
<td>TLP 数据荷载传输量的大小，单位为 DW，编码方式为： <br> 00 0000 0001b = 1DW <br> 00 0000 0010b = 2DW  …… <br> 11 1111 1111b = 1023DW <br> 00 0000 0000 = 1024DW</td>
</tr>
<tr>
<td>Last  DW BE[3:0]  末尾 DW 的字节使能  (Last  DW Byte Enable)</td>
<td>Byte  7  Bit  7:4</td>
<td>这个字段中的 4 个高有效的 bit，与数据荷载中最后一个 DW 中的 4 个 Byte 一一对应。 <br> Bit 7 = 1：末尾 DW 的 Byte 3 是有效的；否则为无效的。 <br> Bit 6 = 1：末尾 DW 的 Byte 2 是有效的；否则为无效的。 <br> Bit 5 = 1：末尾 DW 的 Byte 1 是有效的；否则为无效的。 <br> Bit 4 = 1：末尾 DW 的 Byte 0 是有效的；否则为无效的。</td>
</tr>
<tr>
<td>1<sup>st</sup>  DW BE[3:0]  第一个 DW 的字节使能  (First  DW Byte Enable)</td>
<td>Byte  7  Bit  3:0</td>
<td>这个字段中的 4 个高有效的 bit，与数据荷载中第一个 DW 中的 4 个 Byte 一一对应。 <br> Bit 3 = 1：末尾 DW 的 Byte 3 是有效的；否则为无效的。 <br> Bit 2 = 1：末尾 DW 的 Byte 2 是有效的；否则为无效的。 <br> Bit 1 = 1：末尾 DW 的 Byte 1 是有效的；否则为无效的。 <br> Bit 0 = 1：末尾 DW 的 Byte 0 是有效的；否则为无效的。</td>
</tr>
</tbody>
</table>
<p>表 5‑2 通用 TLP Header 的各字段摘要</p>
<h4 id="524-tlp-header-generic-tlp-header-details">5.2.4     通用 TLP Header 详细说明（Generic TLP Header Details）<a class="headerlink" href="#524-tlp-header-generic-tlp-header-details" title="Permanent link">&para;</a></h4>
<p>在接下来的几个小节中，我们将对图 5‑3 中展示的 TLP Header 的每一个字段都进行细节描述。</p>
<h5 id="5241-header-typeformat">5.2.4.1   Header 的 Type/Format 字段编码含义<a class="headerlink" href="#5241-header-typeformat" title="Permanent link">&para;</a></h5>
<p>表 5‑3 中总结了 TLP Header 中 Type 字段和 Fmt 字段（Format）的编码含义。</p>
<table>
<thead>
<tr>
<th>TLP 事务种类</th>
<th>Fmt[2:0]</th>
<th>Type[4:0]</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory  Read 请求  （MRd）</td>
<td>000=3DW，无数据  001=4DW，无数据</td>
<td>0 0000</td>
</tr>
<tr>
<td>Memory  Read Locked 请求  （MRdLk）</td>
<td>000=3DW，无数据  001=4DW，无数据</td>
<td>0  0001</td>
</tr>
<tr>
<td>Memory  Write 请求  （MWr）</td>
<td>010=3DW，有数据  011=4DW，有数据</td>
<td>0  0000</td>
</tr>
<tr>
<td>IO  Read 请求  （IORd）</td>
<td>000=3DW，无数据  （IO 请求为 3DW Header）</td>
<td>0  0010</td>
</tr>
<tr>
<td>IO  Write 请求  （IOWr）</td>
<td>010=3DW，有数据  （IO 请求为 3DW Header）</td>
<td>0  0010</td>
</tr>
<tr>
<td>配置 Type 0 Read 请求  （CfgRd0）</td>
<td>000=3DW，无数据</td>
<td>0  0100</td>
</tr>
<tr>
<td>配置 Type 0 Write 请求  （CfgWr0）</td>
<td>010=3DW，有数据</td>
<td>0  0100</td>
</tr>
<tr>
<td>配置 Type 1 Read 请求  （CfgRd1）</td>
<td>000=3DW，无数据</td>
<td>0  0101</td>
</tr>
<tr>
<td>配置 Type 1 Write 请求  （CfgWr1）</td>
<td>010=3DW，有数据</td>
<td>0  0101</td>
</tr>
<tr>
<td>Message 请求  （Msg）</td>
<td>001=4DW，无数据</td>
<td>1  0 rrr*  （见表 4‑10）</td>
</tr>
<tr>
<td>Message 带数据的请求  （MsgD）</td>
<td>011=4DW，有数据</td>
<td>1  0 rrr*  （见表 4‑10）</td>
</tr>
<tr>
<td>完成包 Completion  （Cpl）</td>
<td>000=3DW，无数据</td>
<td>0  1010</td>
</tr>
<tr>
<td>完成包带数据  （CplD）</td>
<td>010=3DW，有数据</td>
<td>0  1010</td>
</tr>
<tr>
<td>锁定的完成包  （CplLk）</td>
<td>000=3DW，无数据</td>
<td>0  1011</td>
</tr>
<tr>
<td>锁定的完成包带数据  （CplDLk）</td>
<td>010=3DW，有数据</td>
<td>0  1011</td>
</tr>
<tr>
<td>获取和增加原子操作请求  （Fetch and Add AtomicOP Request）</td>
<td>010=3DW，有数据  011=4DW，有数据</td>
<td>0  1100</td>
</tr>
<tr>
<td>无条件的交换原子操作请求  （Unconditional Swap AtomicOP Request）</td>
<td>010=3DW，有数据  011=4DW，有数据</td>
<td>0  1101</td>
</tr>
<tr>
<td>对比和交换原子操作请求  （Compare and Swap AtomicOP Request）</td>
<td>010=3DW，有数据  011=4DW，有数据</td>
<td>0  1110</td>
</tr>
<tr>
<td>本地 TLP 前缀  （Local TLP Prefix）</td>
<td>100=TLP  Prefix</td>
<td>0L3L2L1L0</td>
</tr>
<tr>
<td>端到端 TLP 前缀  （End-to-End TLP Prefix）</td>
<td>100=TLP  Prefix</td>
<td>1E3E2E1E0</td>
</tr>
</tbody>
</table>
<p>表 5‑3 TLP Header 的 Type 字段和 Fmt 字段编码含义</p>
<h5 id="5242-digestecrc">5.2.4.2   Digest/ECRC 字段<a class="headerlink" href="#5242-digestecrc" title="Permanent link">&para;</a></h5>
<p>TLP 的 Digest 位表示是否存在 ECRC（End-to-End CRC）。如果当前支持这个可选的特性，并且软件也启用了它，那么设备将会给自己产生的所有 TLP 都计算并且添加上一个 ECRC。需要注意，使用 ECRC 要求设备含有可选的 Advanced Error Reporting 寄存器，这是因为它的能力（Capability）和控制寄存器就位于 Advanced Error Reporting 寄存器中。</p>
<h6 id="l-ecrc">l ECRC 的生成和检查<a class="headerlink" href="#l-ecrc" title="Permanent link">&para;</a></h6>
<p>ECRC 覆盖了所有在跨 Fabric 转发时不需要更改的字段。然而，当一个数据包在拓扑结构中移动时，有两个 bit 是可以合法的进行改变的：</p>
<ul>
<li>
<p>Type 字段的 Bit 0：在一个配置事务通过一个 Bridge 时，这个配置事务有可能从 Type 1 变成 Type 0，因为这个 Bridge 的次级总线有可能就是配置事务的目标总线。在这个情况下，Type 地段的 bit 0 的值就会从 1 变成 0。</p>
</li>
<li>
<p>EP（Error/Poisoned）bit：当一个 TLP 在网络结构中移动时，如果与这个数据包相关的数据被认为是损坏的，那么就有可能引发这个 bit 值的改变。这是一种可选的特性，称为错误转发（error forwarding）。</p>
</li>
</ul>
<h6 id="l-ecrc_1">l 谁来检查 ECRC<a class="headerlink" href="#l-ecrc_1" title="Permanent link">&para;</a></h6>
<p>ECRC 的预定目标是 TLP 的最终接收者。对 LCRC（Link CRC）的校验是用来验证在当前给定链路上的传输没有出错，但是会在 Switch/Bridge 的出口端口（egress port）重新计算一个 LCRC，然后再转发给下一级链路，也就是说同一个 LCRC 的作用范围不会跨 Switch/Bridge，那么这将会使得 Switch/Bridge 这些路由元件内部发生的错误被掩盖。为了解决这个问题，就在 TLP 在 Requester 到 Completer 的整个传输过程中都加上一个不会改变的 ECRC（也就是这个过程中 ECRC 都不会被其他设备重新计算和替换）。当目标设备检查 ECRC 时，任何在整个传输过程中发生的错误都会极容易被发现。</p>
<p>关于 ECRC 校验中 Switch 的作用，PCIe 协议做了两个声明：</p>
<ul>
<li>
<p>如果一个 Switch 支持 ECRC 校验，那么它需要对 TLP 目的地为 Switch 自身时，对这个 TLP 中的 ECRC 进行校验。如果 TLP 的目的地并不是 Switch 自身，那么 Switch 必须在保持 ECRC 不变的前提下对其进行转发，把 ECRC 作为 TLP 不可分割的一部分。“On all other TLPs a Switch must preserve the ECRC (forward it untouched) as an integral part of the TLP.”</p>
</li>
<li>
<p>注意，Switch 也可以对通过它的 TLP 进行 ECRC 检查。由 Switch 发现的 ECRC 错误的报告方法和其他设备一样，但是这不会改变 TLP 通过 Switch 的继续传输。“Note that a Switch may perform ECRC checking on TLPs passing through the Switch. ECRC Errors detected by the Switch are reported in the same way any other device would report them, but do not alter the TLPs passage through the Switch.”</p>
</li>
</ul>
<h5 id="5243-using-byte-enables">5.2.4.3   使用字节使能（Using Byte Enables）<a class="headerlink" href="#5243-using-byte-enables" title="Permanent link">&para;</a></h5>
<h6 id="l">l 整体说明<a class="headerlink" href="#l" title="Permanent link">&para;</a></h6>
<p>类似 PCI 一样，对于有时传输大小或者起始/结束地址不是 DW 对齐时，PCIe 也需要一种机制来根据需要协调其 DW 对齐地址。为了达到这个目的，PCIe 利用了 2 个字节使能（Byte Enable）字段，如图 5‑3 中和表 5‑2 中所介绍，分别是首 DW 字节使能（First DW Byte Enable）和尾 DW 字节使能（Last DW Byte Enable），它们使得 Requester 可以对第一个 DW 和最后一个 DW 真正有效传输的字节进行限定。</p>
<h6 id="l_1">l 字节使能规则<a class="headerlink" href="#l_1" title="Permanent link">&para;</a></h6>
<ol>
<li>
<p>字节使能地各个 bit 是高有效的。如果某个字节使能 bit 值为 0，那么就表示数据荷载中相应的字节不应该被 Completer 使用，因为这个字节是无效的。若某个字节使能 bit 值为 1，那么就说明相应的字节应该被 Completer 使用。</p>
</li>
<li>
<p>如果有效的数据全都在一个单独的 DW 中，那么尾 DW 字节使能（Last DW Byte Enable）必须为 0000b。</p>
</li>
<li>
<p>如果 Header 中的 Length 字段表示了这次传输数据量大于 1DW，那么首 DW 字节使能（First DW Byte Enable）至少要有 1 个 bit 是有效的。</p>
</li>
<li>
<p>如果 Header 中的 Length 字段表示了这次传输数据量大于等于 3DW，那么首 DW 字节使能和尾 DW 字节使能都必须是相连的 bit 为 1。在这种情况中，字节使能仅能用来提供有效起始地址和结束地址与 DW 对齐地址的字节偏移量。</p>
</li>
<li>
<p>如果传输数据量大小为 1DW，那么才能允许只有首 DW 字节使能内是不连续为 1 的情况。</p>
</li>
<li>
<p>如果传输数据量大小为 1-2DW，那么才能允许首 DW 字节使能和第二 DW 字节使能内都是不连续为 1 的情况。</p>
</li>
<li>
<p>如果一个写请求，其 Length 字段表示其数据传输长度为 1DW，但是它的字节使能均为无效，这种情况对 Completer 不会有影响。</p>
</li>
<li>
<p>如果一个读请求，其 Length 字段表示其需要的数据传输长度为 1DW，但是没有字节使能有效，那么 Completer 会返回一个 1DW 数据荷载，这种数据荷载是未定义数据（undefined data）。这种情况可能被用作一种刷新机制（Flush mechanism），它利用事务排序规则，在这个 undefine data 的读请求完成包返回之前，强制之前发出的所有 posted write 输出到内存中。</p>
</li>
</ol>
<h6 id="l_2">l 字节使能示例<a class="headerlink" href="#l_2" title="Permanent link">&para;</a></h6>
<p>如图 5‑4 展示了字节使能字段是如何使用的。注意，数据传输长度必须从第一个 DW 中的任何有效字节延伸至最后一个 DW 中的任何有效字节。因为数据传输量大于 2DW，字节使能就只能用来标识这次传输中起始地址的位置（2d）和结束地址的位置（34d）。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image218.jpg" /></p>
<p>图 5‑4 首 DW 字节使能和尾 DW 字节使能字段的使用</p>
<h5 id="5244-transaction-descriptor-fields">5.2.4.4   事务描述符字段（Transaction Descriptor Fields）<a class="headerlink" href="#5244-transaction-descriptor-fields" title="Permanent link">&para;</a></h5>
<p>当事务在 Requester 和 Completer 之间移动时，必须要能够对各个事务进行唯一的标识，因为在任何时刻的 Requester 中都有可能有许多的拆分事务在排队。为了更好的进行标识，PCIe 协议在 TLP Header 中定义了多个重要字段，来组成一个唯一的事务描述符（Transaction Descriptor），如图 5‑5 所示。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image220.jpg" /></p>
<p>图 5‑5 事务描述符字段</p>
<p>虽然事务描述符在 TLP Header 中并不是位置全连续的字段，但是这些不连续字段合起来可以一起描述事务的关键属性，包括：</p>
<h6 id="l-idtransaction-id">l 事务 ID（Transaction ID）<a class="headerlink" href="#l-idtransaction-id" title="Permanent link">&para;</a></h6>
<p>事务 ID 由 Requester ID（Requester 的 BDF）和 TLP 的 Tag 字段共同组成。</p>
<h6 id="l-traffic-class">l 流量类型（Traffic Class）<a class="headerlink" href="#l-traffic-class" title="Permanent link">&para;</a></h6>
<p>流量类型（Traffic Class，TC）是由 Requester 的 Device Core 来添加进 TLP 的，并且在拓扑结构中从 Requester 传输到 Completer 的过程中 TC 都不发生改变。在拓扑结构的每个链路中，TC 都映射到其中一个虚拟通道（Virtual Channel）。</p>
<h6 id="l-transaction-attributes">l 事务属性（Transaction Attributes）<a class="headerlink" href="#l-transaction-attributes" title="Permanent link">&para;</a></h6>
<p>用于表示基于 ID 的排序（ID-based Ordering）、宽松排序（Relaxed Ordering）以及无窥探（No Snoop）的 bit 也存在于请求包中，被发送给 Completer。</p>
<h5 id="5245-tlp">5.2.4.5   带有数据荷载的 TLP 的一些额外规则<a class="headerlink" href="#5245-tlp" title="Permanent link">&para;</a></h5>
<p>当一个 TLP 带有数据荷载时，就要遵从如下规则：</p>
<ol>
<li>
<p>Length 字段仅表示数据荷载的长度。</p>
</li>
<li>
<p>数据荷载的首字节（紧挨着 Header 的字节）的地址永远是最低位的。</p>
</li>
<li>
<p>Length 字段永远表示的是整数 DW 的传输长度。对于不满整数 DW 的情况是使用首 DW 字节使能和尾 DW 字节使能来进行表示的。</p>
</li>
<li>
<p>在协议中有声明，当一个 Completer 在响应一个单独的 Memory 请求时如果返回了多个 TLP，那么中间的（也就是非首尾的）TLP 的数据荷载的地址必须结束于 RC 的 64byte 或 128byte 自然对齐的边界上。具体是那种边界是由一个可配置位称为 RCB（读完成边界，Read Completion Boundary）来控制的。所有的其他设备遵循 PCI-X 协议，并会将这种情况的 TLP 截断在 128byte 自然对齐边界上。</p>
</li>
<li>
<p>当发送 Message 请求时，Length 字段是保留字段，除非 Message 是带有数据荷载的，也就是 MsgD。</p>
</li>
<li>
<p>TLP 的数据荷载一定不能大于设备控制寄存器（Device Control Register）中的最大数据荷载字段（Max_Payload_Size）。因为只有写事务会带有数据荷载，因此这种限制并不应用于读请求。接收方需要在被写入时检查是否存在 Max_Payload_Size 的违例，如果存在则认为这是一个畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>接收方还需要检查 Length 字段和 TLP 实际传输的数据荷载长度。如果二者不相同则认为这是一个畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>请求包中的起始地址和传输长度的组合信息，一定不能造成跨 4KB 边界的 Memory 访问。虽然这种检查是可选的，但是一旦发现了跨 4KB 边界访问的情况就认为这是一个畸形 TLP（Malformed TLP）。</p>
</li>
</ol>
<h4 id="525-tlp-tlp-tlp">5.2.5     具体的 TLP 格式：请求 TLP 和完成 TLP<a class="headerlink" href="#525-tlp-tlp-tlp" title="Permanent link">&para;</a></h4>
<p>在本节中，将会描述用来构成具体的一些事物类型的 TLP 3DW Header 和 4DW Header。许多通用的字段就如前文所述，因此我们把重点放在那些需要根据具体事务类型进行具体处理的字段上。接下来的几个小节是关于 TLP Header 的详细描述，相关的 TLP 类型为：1）IO Request，2）Memory Requests，3）Configuration Requests，4）Completions，以及 5）Message Request。</p>
<h5 id="5251-io-io-request">5.2.5.1   IO 请求（IO Request）<a class="headerlink" href="#5251-io-io-request" title="Permanent link">&para;</a></h5>
<p>虽然协议中不鼓励使用 IO 事务，但是对于传统遗留设备还是允许的，并且对于软件来说需要通过 IO 事务来兼容那些存在系统 IO 映射而不是内存映射的设备。虽然 IO 事务从技术上讲是可以访问 32bit IO 范围的，但是实际上许多系统（和 CPU）都会将 IO 访问限制在低 16bit（64KB）范围内。图 5‑6 展示了系统 IO 映射以及 16bit 和 32bit 地址边界。自身不是传统遗留设备的设备是不允许访问 BAR 中的 IO 地址空间的。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image222.jpg" /></p>
<p>图 5‑6 系统 IO 映射</p>
<h6 id="l-io-request-header">l IO Request Header 的格式<a class="headerlink" href="#l-io-request-header" title="Permanent link">&para;</a></h6>
<p>如图 5‑7 所示是一个 3DW IO Request Header，其中的每个字段都会在接下来的内容中进行描述。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image224.jpg" /></p>
<p>图 5‑7 3DW IO Request Header 格式</p>
<h6 id="l-io-request-header_1">l IO Request Header 各字段<a class="headerlink" href="#l-io-request-header_1" title="Permanent link">&para;</a></h6>
<p>一个 IO Request Header 中的每个字段的位置和作用都在表 5‑4 中进行了描述。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位于 Header 中的 Byte/Bit</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  （Format）</td>
<td>Byte  0 Bit 7:5</td>
<td>IO 请求的包格式字段：  000b=IO  Read（3DW，无数据）  010b=IO  Write（3DW，有数据）</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0 Bit 4:0</td>
<td>0 0010b=IO 请求</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  （Traffic Class）</td>
<td>Byte  1 Bit 6:4</td>
<td>IO 请求的 TC 永远为 0，确保这些包永远不会干扰高优先级的包。</td>
</tr>
<tr>
<td>Attr[2]  属性  （Attribute）</td>
<td>Byte  1 Bit 2</td>
<td>由于 IO 请求不使用基于 ID 的排序（ID-based Ordering），因此这个字段为保留字段。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  （TLP Processing Hints）</td>
<td>Byte  1 Bit 0</td>
<td>由于 IO 请求不使用 TLP 处理提示（TLP Processing Hints），因此这个字段为保留字段。</td>
</tr>
<tr>
<td>TD  TLP 摘要  （TLP Digest）</td>
<td>Byte  2 Bit 7</td>
<td>表示 TLP 的末尾是否存在 Digest 字段，也就是 ECRC。</td>
</tr>
<tr>
<td>EP  受污染的数据  （Poisoned Data）</td>
<td>Byte  2 Bit 6</td>
<td>表示 TLP 的数据荷载（如果有）是否被污染（poisoned）。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  （Attribute）</td>
<td>Byte  2 Bit 5:4</td>
<td>由于 IO 请求不使用宽松排序（Relaxed  Ordering）和无窥探（No Snoop），因此这个字段为 0。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  （Address Type）</td>
<td>Byte  2 Bit 3:2</td>
<td>由于 IO 请求不使用地址类型字段，因此这个字段必须为 0。</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2 Bit 1:0  Byte  3 Bit 7:0</td>
<td>该字段用来表示以 DW 为单位的数据荷载大小。对于 IO 请求来说，这个字段为 1，因为 IO 请求不能传输超过 4Byte。由首 DW 字节使能来限定使用哪个 Byte。</td>
</tr>
<tr>
<td>Requester  ID[15:0]  Requester  ID</td>
<td>Byte  4 Bit 7:0  Byte  5 Bit 7:0</td>
<td>用于表示相应完成包的“返回地址”。  Byte 4,7:0=Bus  Number  Byte 5,7:3=Device  Number  Byte 5,2:0=Function  Number</td>
</tr>
<tr>
<td>Tag[7:0]  Tag</td>
<td>Byte  6 Bit 7:0</td>
<td>这个字段用来标识来自 Requester 的具体每个请求。每个被发出的请求包都会被分配一个独一无二的 Tag 值。默认情况下，只使用 Tag[4:0]，但是扩展 Tag（Extended Tag）和 Phantom Function 可选项可以将 Tag 的使用扩展为 Tag[10:0]，这样就允许多达 2048 个未完成的请求同时进行。</td>
</tr>
<tr>
<td>Last  DW BE[3:0]  尾 DW 字节使能</td>
<td>Byte  7 Bit 7:4</td>
<td>因为 IO 请求数据大小只能是 1DW 以内，所以这个字段必须为 0000b。</td>
</tr>
<tr>
<td>1<sup>st</sup>  DW BE[3:0]  首 DW 字节使能</td>
<td>Byte  7 Bit 3:0</td>
<td>这个字段用于限定第一个 DW 数据内的有效字节。对于 IO 请求来说，所有的 bit 组合都是允许的（包括 0000b）。</td>
</tr>
<tr>
<td>Address[31:2]  地址</td>
<td>Byte  8 Bit 7:0  Byte  9 Bit 7:0  Byte  10 Bit 7:0  Byte  11 Bit 7:2</td>
<td>该字段是 32bit 起始地址的高 30bit。而最低 2bit 是保留位（00b），这使得 32bit 起始地址一定是 DW 对齐的。</td>
</tr>
</tbody>
</table>
<p>表 5‑4 IO Request Header 各字段</p>
<h5 id="5252-memory-memory-request">5.2.5.2   Memory 请求（Memory Request）<a class="headerlink" href="#5252-memory-memory-request" title="Permanent link">&para;</a></h5>
<p>PCIe 的 Memory 事务包含两种类型：第一种是读请求及其相对应的完成包，第二种是写请求。系统内存映射如所示，展示了 3DW 与 4DW 的 Memory 请求包。需要记住协议规范中多次重申的一点，Memory 传输绝对不允许跨 4KB 地址边界。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image226.jpg" /></p>
<p>图 5‑8 3DW 和 4DW 的 Memory Request Header 格式</p>
<h6 id="l-memory-request-header">l Memory Request Header 各字段<a class="headerlink" href="#l-memory-request-header" title="Permanent link">&para;</a></h6>
<p>一个 4DW 的 Memory Request Header 中的每个字段的位置和作用都在表 5‑5 中进行了描述。注意，3DW 和 4DW Header 的区别仅仅是起始地址字段的位置和字段大小不同。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位于 Header 中的 Byte/Bit</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  （Format）</td>
<td>Byte  0 Bit 7:5</td>
<td>IO 请求的包格式字段：  000b=Memory  Read（3DW 无数据）  010b=Memory  Write（3DW 有数据）  001b=Memory  Read（4DW 无数据）  011b=Memory  Write（4DW 有数据）  1xxb=TLP 前缀已经被添加到包的开头。更多内容请参阅“TPH（TLP Processing Hints）”一节</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0 Bit 4:0</td>
<td>0 0000b=  Memory Read 或 Write  0 0001b=  Memory Read Locked  Type 字段与 Fmt[1:0]共同指定事务类型、Header 大小以及是否有数据荷载。</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  （Traffic Class）</td>
<td>Byte  1 Bit 6:4</td>
<td>这个字段的编码信息是请求包及其完成包的流量类型。  000b=TC  0（默认）  ……  111b=TC  7  更多内容请参阅“Traffic Class（TC）”一节。</td>
</tr>
<tr>
<td>Attr[2]  属性  （Attribute）</td>
<td>Byte  1 Bit 2</td>
<td>表示这个 TLP 是否使用基于 ID 的排序（ID-based Ordering）。更多内容请参阅“ID Based Ordering（IDO）”一节。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  （TLP Processing Hints）</td>
<td>Byte  1 Bit 0</td>
<td>指示是否包含 TLP 提示信息。更多内容请参阅“TPH（TLP Processing  Hints）”一节。</td>
</tr>
<tr>
<td>TD  TLP 摘要  （TLP Digest）</td>
<td>Byte  2 Bit 7</td>
<td>如果为 1，则 TLP 中存在 TLP Digest 字段，即存在 ECRC。  一些规则：  所有的接收者都要使用这个 TD bit 检查是否存在 Digest 字段。  l TD=1 但是不含有 Digest 字段的 TLP 被当做畸形（Malformed）  l 如果 TD=1，且接收者也启用了 ECRC 检查，那么就必须对 ECRC 进行检查。  l 如果接收者并不支持可选的 ECRC 校验，那么它必须要忽略 TLP 中的 Digest 字段。</td>
</tr>
<tr>
<td>EP  受污染的数据  （Poisoned Data）</td>
<td>Byte  2 Bit 6</td>
<td>如果为 1，那么伴随这个 TLP 的数据荷载就都被认为是有错误的，尽管这个事务还是可以照常完成。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  （Attribute）</td>
<td>Byte  2 Bit 5:4</td>
<td>l Bit 5 =宽松排序（Relaxed Ordering）  当 Bit 5=1，这个 TLP 就使用 PCI-X 的宽松排序。否则，使用严格的 PCI 排序。  l Bit 6=无窥探（No Snoop）  当 Bit 6=1，系统软件就不需要进行关于这个 TLP 的处理器 Cache 一致性窥探。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  （Address Type）</td>
<td>Byte  2 Bit 3:2</td>
<td>这个字段支持虚拟系统（virtualized systems）的地址翻译。地址翻译协议是由一个单独的协议规范来描述的，称为地址翻译服务（Address Translation Services），AT 中的编码信息为：  00=默认/未翻译  01=翻译请求  10=已翻译  11=保留位</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2 Bit 1:0  Byte  3 Bit 7:0</td>
<td>TLP 数据荷载的长度，单位为 DW。最大为 1024DW（4KB），编码如下：  00  0000 0001b=1DW  00  0000 0010b=2DW  ……  11  1111 1111b=1023DW  00  0000 0000b=1024DW</td>
</tr>
<tr>
<td>Requester  ID[15:0]  Requester  ID</td>
<td>Byte  4 Bit 7:0  Byte  5 Bit 7:0</td>
<td>用于表示这个请求的相应完成包的“返回地址”。  Byte 4,7:0=Bus  Number  Byte 5,7:3=Device  Number  Byte 5,2:0=Function  Number</td>
</tr>
<tr>
<td>Tag[7:0]  Tag</td>
<td>Byte  6 Bit 7:0</td>
<td>这个字段用来标识来自 Requester 的具体每个请求。每个被发出的请求包都会被分配一个独一无二的 Tag 值。默认情况下，只使用 Tag[4:0]，如果 Control Register 中的 Extended Tag 位被置为 1，那么可以将 Tag 的使用扩展为 Tag[7:0]，这样就允许最多使用 256 个 Tag。</td>
</tr>
<tr>
<td>Last  DW BE[3:0]  尾 DW 字节使能</td>
<td>Byte  7 Bit 7:4</td>
<td>这个字段用于限定最后一个 DW 数据内的有效字节</td>
</tr>
<tr>
<td>1<sup>st</sup>  DW BE[3:0]  首 DW 字节使能</td>
<td>Byte  7 Bit 3:0</td>
<td>这个字段用于限定第一个 DW 数据内的有效字节。</td>
</tr>
<tr>
<td>Address[63:32]  高 32bit 地址</td>
<td>Byte  8 Bit 7:0  Byte  9 Bit 7:0  Byte  10 Bit 7:0  Byte  11 Bit 7:2</td>
<td>该字段是 Memory 传输的 64bit 起始地址的高 32bit。</td>
</tr>
<tr>
<td>Address[31:2]  低 32bit 地址</td>
<td>Byte  12 Bit 7:0  Byte  13 Bit 7:0  Byte  14 Bit 7:0  Byte  15 Bit 7:2</td>
<td>该字段是 Memory 传输的 64bit 起始地址的低 32bit。而最低 2bit 是保留位始终为 0，这样就强制起始地址是 DW 对齐的。</td>
</tr>
</tbody>
</table>
<p>表 5‑5 4DW Memory Request Header 各字段</p>
<h6 id="l-memory-request">l Memory Request 注意事项<a class="headerlink" href="#l-memory-request" title="Permanent link">&para;</a></h6>
<p>Memory 请求的特性包括：</p>
<ol>
<li>
<p>Memory 数据传输不允许跨 4KB 边界。</p>
</li>
<li>
<p>所有的内存映射写（Memory-Mapped Write）都是 Posted 的，以此来提升性能。</p>
</li>
<li>
<p>使用 32bit 或者 64bit 地址方式。</p>
</li>
<li>
<p>数据荷载大小在 0-1024DW 之间（0-4KB）。</p>
</li>
<li>
<p>QoS（Quality of Service）特性可以被使用，最多可以有 8 个流量类型。</p>
</li>
<li>
<p>No Snoop 属性可以在事务访问主存时，用来减轻系统对窥探处理器 Cache 的需求。</p>
</li>
<li>
<p>Relaxed Ordering 属性可以使得数据包传输路径上的设备对这个 TLP 使用宽松排序规则，以此来提升性能。</p>
</li>
</ol>
<h5 id="5253-configuration-configuration-request">5.2.5.3   Configuration 请求（Configuration Request）<a class="headerlink" href="#5253-configuration-configuration-request" title="Permanent link">&para;</a></h5>
<p>PCIe 像 PCI 一样使用 Type 0 和 Type 1 配置请求，以此来保持向后兼容性。一个 Type 1 配置请求会向下行传播，直到一个 Bridge 的次级总线（Secondary Bus）正好是这个 Type 1 配置请求的目标总线，在这时这个 Bridge 就会把这个配置事务从 Type 1 转换为 Type 0。Bridge 是通过此前编程写入的总线号寄存器来得知何时应该对配置事务进行 Type 转换以及继续转发，其中总线号寄存器包括主总线号（Primary Bus Number）、次级总线号（Secondary Bus Number）以及从属总线号（Subordinate Bus Number）。关于这里的更多内容，请参阅“传统 PCI 机制（Legacy PCI Mechanism）”一节。</p>
<p>如图 5‑9 中，一个 Type 1 配置请求正在按照规则向下行移动，它在 Switch 左侧的下行端口的 Bridge 被转换成 Type 0，这种转换是通过改变 TLP Header 中的 Type 字段 Bit 0 来完成的（Type 从 0 0101b 变为 0 0100b）。注意，不同于 PCI，PCIe 中下行的一条链路上只能由一个设备，因此链路上不需要有 IDSEL 或者其他指示信号来告诉设备需要声明自己占有 Type 0 配置请求，也就是说设备只要从上行收到了 Type 0 配置请求，就知道这个配置请求的目标设备就必然是自己。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image228.jpg" /></p>
<p>图 5‑9 3DW 配置请求以及 Header 格式</p>
<h6 id="l-configuration-request-header">l Configuration Request Header 各字段的定义<a class="headerlink" href="#l-configuration-request-header" title="Permanent link">&para;</a></h6>
<p>图 5‑9 中展示的 Configuration Request Header 中的每个字段的位置和作用都在表 5‑6 中进行了描述。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位于 Header 中的 Byte/Bit</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  （Format）</td>
<td>Byte  0 Bit 7:5</td>
<td>配置请求始终为 3DW Header：  000b=Configuration  Read（无数据）  010b=  Configuration Write（有数据）</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0 Bit 4:0</td>
<td>0 0100b=  Type 0 配置请求  0 0101b=  Type 1 配置请求</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  （Traffic Class）</td>
<td>Byte  1 Bit 6:4</td>
<td>配置请求的 TC 必须为 0，以确保这些配置包永远不会影响到高优先级的包。</td>
</tr>
<tr>
<td>Attr[2]  属性  （Attribute）</td>
<td>Byte  1 Bit 2</td>
<td>配置请求的这个字段为保留字段，必须为 0。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  （TLP Processing Hints）</td>
<td>Byte  1 Bit 0</td>
<td>配置请求的这个字段为保留字段，必须为 0。</td>
</tr>
<tr>
<td>TD  TLP 摘要  （TLP Digest）</td>
<td>Byte  2 Bit 7</td>
<td>用于指示 TLP 的末尾是否有 1DW 的 Digest 字段。</td>
</tr>
<tr>
<td>EP  受污染的数据  （Poisoned Data）</td>
<td>Byte  2 Bit 6</td>
<td>用于指示数据荷载是被污染的。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  （Attribute）</td>
<td>Byte  2 Bit 5:4</td>
<td>配置请求的 Relaxed Ordering 和 No Snoop 字段都为 0。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  （Address Type）</td>
<td>Byte  2 Bit 3:2</td>
<td>配置请求的 Address Type 字段为保留字段，必须为 0。</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2 Bit 1:0  Byte  3 Bit 7:0</td>
<td>配置请求的数据荷载大小字段永远为 1，4bit 字节使能的所有组合都是允许的。</td>
</tr>
<tr>
<td>Requester  ID[15:0]  Requester  ID</td>
<td>Byte  4 Bit 7:0  Byte  5 Bit 7:0</td>
<td>用于表示这个请求的相应完成包的“返回地址”。  Byte 4,7:0=Bus  Number  Byte 5,7:3=Device  Number  Byte 5,2:0=Function  Number</td>
</tr>
<tr>
<td>Tag[7:0]  Tag</td>
<td>Byte  6 Bit 7:0</td>
<td>这个字段用来标识来自 Requester 的具体每个请求。每个被发出的请求包都会被分配一个独一无二的 Tag 值。默认情况下，只使用 Tag[4:0]（也就是同时可以有 32 个未完成的事务在进行），如果 Control Register 中的 Extended Tag 位被置为 1，那么可以将 Tag 的使用扩展为 Tag[7:0]，这样就允许最多使用 256 个 Tag。</td>
</tr>
<tr>
<td>Last  DW BE[3:0]  尾 DW 字节使能</td>
<td>Byte  7 Bit 7:4</td>
<td>这个字段用于限定最后一个 DW 数据内的有效字节。由于配置请求的数据荷载只能为 1DW，因此这个字段必须为 0</td>
</tr>
<tr>
<td>1<sup>st</sup>  DW BE[3:0]  首 DW 字节使能</td>
<td>Byte  7 Bit 3:0</td>
<td>这个字段用于限定第一个 DW 数据内的有效字节。对于配置请求来说，这个字段的所有组合都是允许的（包括全 0）。</td>
</tr>
<tr>
<td>Completer  ID[15:0]  Completer  ID</td>
<td>Byte  8 Bit 7:0  Byte  9 Bit 7:0</td>
<td>用于指示这个配置请求要访问的 Completer。  Byte 8,7:0=Bus Number  Byte 9,7:3=Device Number  Byte 9,2:0=Function Number</td>
</tr>
<tr>
<td>Ext  Register Number[3:0]  扩展寄存器号  （Extended Register Number）</td>
<td>Byte  10 Bit 3:0</td>
<td>这个字段提供了在访问扩展配置空间（Extended Config Space）时 DW 空间的高 4bit，它与 Register Number 共同组合成 10bit 地址，用于访问 1024DW（也就是 4096Byte）的空间。对于 PCI-Compatible 配置空间，这个字段必须为 0。</td>
</tr>
<tr>
<td>Register  Number[3:0]  寄存器号  （Register Number）</td>
<td>Byte  11 Bit 7:0</td>
<td>用于指示寄存器号，是配置 DW 空间的低 8bit。最低的 2bit 始终为 0，以强制进行 DW 对齐的访问。</td>
</tr>
</tbody>
</table>
<p>表 5‑6 配置请求 Header 各字段</p>
<h6 id="l-configuration-request">l Configuration Request 注意事项<a class="headerlink" href="#l-configuration-request" title="Permanent link">&para;</a></h6>
<p>配置请求的 Header 总为 3DW 格式，路由信息为 Bus Number、Device Number 和 Function Number。所有的设备都会在接收到一个 Type 0 配置写请求时从请求包中捕获出它们自己的 Bus Number 和 Device Number。之所以这样，是因为这些设备之后会用自己捕获到的 Type 0 配置写中的 Bus Number 和 Device Number 来作为 Requester ID，用来在以后发起请求时使用。</p>
<h5 id="5254-completion">5.2.5.4   完成包（Completion）<a class="headerlink" href="#5254-completion" title="Permanent link">&para;</a></h5>
<p>Completion（完成包）是用来响应 Non-Posted 请求的，除非有错误阻止了发送完成包。例如，Memory、IO、Configuration Read 请求通常就是由带有数据的完成包来响应。另一方面，IO 或者 Configuration 写请求通常也由无数据的完成包来响应，这种情况下的完成包仅仅是用来报告事务的状态。</p>
<p>在完成包中的许多字段的值，都与它相关的请求包中的字段相同，包括 TC（Traffic Class，流量类型）、Attr（Attribute，属性）以及 Requester ID（请求者 ID，用来将完成包路由回到请求者去）。图 5‑10 中展示了一个响应 Non-Posted 请求的完成包，并且还展示了这个完成包的 3DW Header。在正常操作中，Completer ID 并没有什么额外的用处，但若是在系统调试期间能够知道完成包从哪里来，那么这对错误的诊断就有较大的帮助。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image230.jpg" /></p>
<p>图 5‑10 3DW 完成包 Header 格式</p>
<h6 id="l-completion-header">l Completion Header 各字段的定义<a class="headerlink" href="#l-completion-header" title="Permanent link">&para;</a></h6>
<p>图 5‑10 中展示的 Completion Header 中的每个字段的位置和作用都在表 5‑7 中进行了描述。</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位于 Header 中的 Byte/Bit</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  （Format）</td>
<td>Byte  0 Bit 7:5</td>
<td>完成包始终为 3DW Header：  000b=Cpl，无数据  010b=CplD，有数据</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0 Bit 4:0</td>
<td>0 1010b=完成包</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  （Traffic Class）</td>
<td>Byte  1 Bit 6:4</td>
<td>完成包的该字段必须与相应的请求包相同。</td>
</tr>
<tr>
<td>Attr[2]  属性  （Attribute）</td>
<td>Byte  1 Bit 2</td>
<td>表示这个 TLP 是否使用基于 ID 的排序（ID-based Ordering）。更多内容请参阅“ID Based Ordering（IDO）”一节。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  （TLP Processing Hints）</td>
<td>Byte  1 Bit 0</td>
<td>完成包中，此字段为保留字段</td>
</tr>
<tr>
<td>TD  TLP 摘要  （TLP Digest）</td>
<td>Byte  2 Bit 7</td>
<td>用于指示 TLP 的末尾是否有 1DW 的 Digest 字段，如果为 1 则说明存在。</td>
</tr>
<tr>
<td>EP  受污染的数据  （Poisoned Data）</td>
<td>Byte  2 Bit 6</td>
<td>如果为 1，则表示数据荷载是被污染的。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  （Attribute）</td>
<td>Byte  2 Bit 5:4</td>
<td>完成包的该字段必须与相应的请求包相同。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  （Address Type）</td>
<td>Byte  2 Bit 3:2</td>
<td>完成包的 Address Type 字段为保留字段，必须为 0。</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2 Bit 1:0  Byte  3 Bit 7:0</td>
<td>用于表示完成包数据荷载的大小，单位为 DW。</td>
</tr>
<tr>
<td>Completer  ID[15:0]  Completer  ID</td>
<td>Byte  4 Bit 7:0  Byte  5 Bit 7:0</td>
<td>用于表示 Completer 是谁，用于支持调试。  Byte 4,7:0=Compl  Bus Number  Byte 5,7:3=Compl  Device Number  Byte 5,2:0=Compl  Function Number</td>
</tr>
<tr>
<td>Compl.  Status[2:0]  完成包状态  （Completion Status Code）</td>
<td>Byte  6 Bit 7:5</td>
<td>这个字段用于表示完成包的状态。  000b=Successful  Completion（SC）成功完成  001b=Unsupported  Request（UR）不支持的请求  010b=Config  Req Retry Status（CRS）配置请求重试状态  100b=Completer  Abort（CA）完成者终止  除了上述 bit 组合之外的都是保留码。更多内容请参阅“Summary of Completion Status Codes”一节。</td>
</tr>
<tr>
<td>BCM  字节数已修改  （Byte Count Modified）</td>
<td>Byte  6 Bit 4</td>
<td>这个字段仅由 PCI-X 完成包使用，用来表示 Byte Count 字段仅报告第一个数据荷载的大小，而不是总数据荷载的大小。更多内容请参阅“Using The Byte Count Modified Bit”一节。</td>
</tr>
<tr>
<td>Byte  Count[11:0]  字节数</td>
<td>Byte  6 Bit 3:0  Byte  7 Bit 7:0</td>
<td>Byte Count 字段是用来服务读请求的，它也是来源于原始请求中的 Length 字段。一些特别情况下，会出现使用多完成包返回数据荷载，请参阅“Data  Returned For Read Request”一节</td>
</tr>
<tr>
<td>Requester  ID[15:0]  Requester  ID</td>
<td>Byte  8 Bit 7:0  Byte  9 Bit 7:0</td>
<td>该字段是从原始请求中复制来的，用于作为路由信息来帮助完成包返回 Requester。  Byte 4,7:0=Req  Bus Number  Byte 5,7:3=Req  Device Number  Byte 5,2:0=Req  Function Number</td>
</tr>
<tr>
<td>Tag[7:0]  Tag</td>
<td>Byte  10 Bit 7:0</td>
<td>完成包中的 Tag 必须与相应请求中的 Tag 一样。Requester 收到这个完成包时是通过 Tag 来将完成包与原始请求关联起来的。</td>
</tr>
<tr>
<td>Lower  Address[6:0]  低位地址</td>
<td>Byte  11 Bit 6:0</td>
<td>这个字段是一个读请求所返回的第一组数据的低 7bit 地址。它是由请求 Length 和 Byte Enable 共同计算出来的，它可以展示出在到达下一个读完成包边界之前还能传输多少字节数据，以此来协助 Buffer 管理。更多内容请参阅“Calculation Lower Address Field”一节。</td>
</tr>
</tbody>
</table>
<p>表 5‑7 完成包 Header 格式</p>
<h6 id="l-summary-of-completion-status-codes">l 完成包状态码总结（Summary of Completion Status Codes）<a class="headerlink" href="#l-summary-of-completion-status-codes" title="Permanent link">&para;</a></h6>
<ul>
<li>
<p>000b（SC）Successful Completion 成功完成：请求被正确服务。</p>
</li>
<li>
<p>001b（UR）Unsupported Request 不支持的请求：对于 Completer 来说，此请求是非法的或者是无法被识别的。这是一种出错的情况，至于 Completer 如何进行响应则要根据 Completer 对应的 PCIe 协议版本来。在 PCIe 1.1 之前，这种情况被视为一种不可纠正的错误，但是在 1.1 和之后的版本中，它被作为一种 Advisory Non-Fatal Error（报告的非致命错误）。更多详细内容请参阅“Unsupported Request（UR） Status”一节。</p>
</li>
<li>
<p>010b（CRS）Configuration Request Retry Status 配置请求重试状态：Completer 临时的无法服务一个配置请求，因此这个请求应该稍后再次尝试。</p>
</li>
<li>
<p>100b（CA）Completer Abort 完成者终止：Completer 应该已经对请求事务进行了服务，但是因为某些原因导致了服务失败。这是一种不可纠正的错误。</p>
</li>
</ul>
<h6 id="l-calculating-the-lower-address-field">l 计算低位地址字段（Calculating the Lower Address Field）<a class="headerlink" href="#l-calculating-the-lower-address-field" title="Permanent link">&para;</a></h6>
<p>Completer 设置这个字段是用来反映返回给 Requester 的数据荷载中，第一个 enabled 的字节的字节对齐地址（byte-aligned address）。硬件会通过原始请求中的 DW 起始地址以及首 DW 字节使能字段（1<sup>st</sup> DW Byte Enable）中的字节使能情况，来计算出这个地址的值。</p>
<p>对于 MRd（Memory Read）请求，这个地址就是从 DW 起始地址开始的偏移量：</p>
<ul>
<li>
<p>如果首 DW 字节使能字段为 1111b，也就是第一个 DW 中的所有字节都是有效的，那么偏移量就是 0。此时这个字段就与 DW 对齐的起始地址相同。</p>
</li>
<li>
<p>如果首 DW 字节使能字段为 1110b，也就是第一个 DW 中的高 3 个字节都是有效的，那么偏移量就是 1。此时这个字段就等于 DW 对齐的起始地址+1。</p>
</li>
<li>
<p>如果首 DW 字节使能字段为 1100b，也就是第一个 DW 中的高 2 个字节都是有效的，那么偏移量就是 2。此时这个字段就等于 DW 对齐的起始地址+2。</p>
</li>
<li>
<p>如果首 DW 字节使能字段为 1000b，也就是第一个 DW 中的仅有最高字节是有效的，那么偏移量就是 3。此时这个字段就等于 DW 对齐的起始地址+3。</p>
</li>
</ul>
<p>一旦上述的计算完成，计算结果的低 7bit 就会被放入完成包 Header 的 Lower Address 字段，当读完成包小于整个数据荷载因而需要停止在第一个 RCB（Read Completion Boundary）时，这个字段可以有助于更好的处理这种情况。若想将一个事务拆分成多个部分，则必须要在 RCB 上进行拆分，而到达第一个 RCB 时所传输的字节数量是根据起始地址而定的。</p>
<p>对于 AtomicOp（原子操作）完成包，Lower Address 字段是保留位。对于所有其他完成包类型（非读请求、非原子操作），这个字段必须为 0。</p>
<h6 id="l-using-the-byte-count-modified-bit">l 使用字节数修改位（Using The Byte Count Modified Bit）<a class="headerlink" href="#l-using-the-byte-count-modified-bit" title="Permanent link">&para;</a></h6>
<p>这个 bit 仅由 PCI-X Completer 进行设置，但是如果使用了 PCIe 到 PCI-X 的 Bridge，那么这些 PCI-X Completer 们就也可以出现在 PCIe 拓扑结构中。使用这个 bit 的规则包括：</p>
<ol>
<li>
<p>当一个读请求要拆分成多个完成包来返回数据时，Byte Count Modified 这一位只能由 PCI-X Completer 进行置位。</p>
</li>
<li>
<p>仅有一系列完成包中的第一个可以将这个 bit 置为 1，这表示第一个完成包内包含的 Byte Count 字段只反映这个完成包（第一个完成包）的数据荷载，而不是整个事务的数据荷载（通常情况下是表示整个事务的总数据荷载）。这样 Requester 就知道，即使 Byte Count 看起来似乎表示这是这个请求的最后一个完成包，但是实际上这个完成包之后还会有完成包，以此来满足原始请求对数据量的需求。</p>
</li>
<li>
<p>对于随后的一系列完成包来说，BCM 位必须置为 0，且 Byte Count 字段要用来反映剩下的所有数据荷载额字节数，就像它通常的含义一样。</p>
</li>
<li>
<p>当设备接收到 BCM 位为 1 的完成包时，它必须要正确的处理这种情况。</p>
</li>
<li>
<p>Completer 要在带有数据荷载的完成包中设置 Lower Address 字段，以此来反映返回的第一个有效字节的地址。</p>
</li>
</ol>
<h6 id="l-data-returned-for-read-requests">l 读请求数据返回（Data Returned For Read Requests）:<a class="headerlink" href="#l-data-returned-for-read-requests" title="Permanent link">&para;</a></h6>
<ol>
<li>
<p>一个读请求可能需要多个完成包来返回数据，但是最终传输的数据总量必须等于原始请求中要求的大小，否则可能导致完成包超时错误（Completion Timeout error）。</p>
</li>
<li>
<p>一个完成包只能用于服务一个请求。</p>
</li>
<li>
<p>IO 和 Configuration 读请求所请求的数据量永远是 1DW，并且只能由一个单独的完成包来返回数据。</p>
</li>
<li>
<p>状态码不是 SC（Successful Completion）的完成包将会终止当前事务。</p>
</li>
<li>
<p>在使用多个完成包来响应读请求时，必须注意读完成包边界（RCB，Read Completion Boundary）。对于 RC 来说，RCB 会是 64Bytes 或者 128Bytes，这是因为 RC 可以更改在其端口间移动的数据包的大小，具体的 RCB 的值可以在配置寄存器中看到。</p>
</li>
<li>
<p>Bridge 和 EP 可以用一个 bit 来实现软件对 RCB 大小的选择，64bytes 或者 128bytes。</p>
</li>
<li>
<p>完全在一个对齐 RCB 边界内的完成包们必须一次完成传输，这是因为这些 RCB 边界内的完成包的传输是不会到达 RCB 的，而 RCB 才是允许提前停止传输的位置，这样就必须对一个 RCB 边界内的所有完成包一次完成传输而不能中途停止。</p>
</li>
<li>
<p>对于一个单独的读请求来说，若使用多个完成包来返回数据，那么这些数据必须以地址递增的顺序来返回。</p>
</li>
</ol>
<h6 id="l-receiver-completion-handling-rules">l 接收者对完成包的处理规则（Receiver Completion Handling Rules）:<a class="headerlink" href="#l-receiver-completion-handling-rules" title="Permanent link">&para;</a></h6>
<ol>
<li>
<p>如果一个已经被接收的完成包并没有匹配上任何一个待完成的请求，那么它就是一个 Unexpected Completion（意外完成包），将被当做是一种错误来处理。</p>
</li>
<li>
<p>如果完成包状态不是 SC 或者 CRS，那么就将被当做是错误来处理，并且会清空与之相关联的 Buffer 空间。</p>
</li>
<li>
<p>当 RC 在进行配置事务时接收到一个 CRS 状态的完成包，那么这个配置请求就被终止了。随后要进行的事情是根据具体实现而不同的，但是如果 RC 支持这种 CRS 状态的完成包处理，那么具体的操作将由 RC 控制寄存器中的 CRS Software Visibility 位来进行定义设置。</p>
</li>
</ol>
<p>—  如果 CRS Software Visibility 没有启用，那么 RC 将会重新发出配置请求，直到重复了一定的次数（具体实现中指定）之后就会放弃重发的操作，并认为请求目标存在问题。</p>
<p>—  如果 CRS Software Visibility 是启用的，那么用来支持它的软件都会首先读取 Vendor ID 字段的两个字节，如果硬件接收到了这个读请求的 CRS 完成包，它将给返回的 Vendor ID 将会是 0001h。这个值是 PCI-SIG 规定的保留值，它并不对应任何有效的 Vendor，并会通知软件发生了这样的事件。这使得软件可以在等待目标 Function 准备就绪的这段时间里（通常在复位后需要 1s 时间），去执行其他的任务，而不是停滞不前。任何其他的配置读或者写（除了最开始的配置读 Vendor ID）都会被 RC 自动重试重发，直到达到设计的重复次数。</p>
<ol>
<li>
<p>如果一个请求并不是配置请求，但是它的完成包出现了 CRS 状态，那么这个完成包将被认为是一个畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>当完成包状态码为保留组合时，并不是定义出的那几种，就把它当做 UR（Unsupported Request）一样处理。</p>
</li>
<li>
<p>如果接收到的一个读完成包或者一个原子操作完成包的状态码不是 SC，那么这个完成包就不会携带数据，并且 Requester 必须要考虑终止这个完成包对应的请求。至于 Requester 具体如何处理这种情况则根据具体实现而定。</p>
</li>
<li>
<p>在使用多个完成包来响应一个读请求的情况下，任何一个完成包的状态只要不是 SC，那么就会终止这个事务。设备如何处理出错之前接收到的数据根据具体实现而定。</p>
</li>
<li>
<p>为了保持对 PCI 的兼容性，RC 需要在一个配置事务被 UR 结束时，合成一个全 1 的读取值。这就类同于枚举软件尝试从不存在的设备中读取数据时的出现的 PCI Master Abort 一样。</p>
</li>
</ol>
<h5 id="5255-message-requests">5.2.5.5   消息请求（Message Requests）<a class="headerlink" href="#5255-message-requests" title="Permanent link">&para;</a></h5>
<p>Message 请求取代了 PCI/PCI-X 中使用的许多中断（interrupt）、错误（error）和电源管理（power management）的边带信号。所有的 Message 请求使用的都是 4DW Header 格式，但是并不是每种 Message 都使用了 Header 中的每一个字段。对于 Header 中的 Byte8-15 来说，在一些种类的 Message 中就没有其定义，在这种情况下它就是保留字段。Message 的处理方式更像是 Posted 的 MWr 事务，但是 Message 的路由方式可以是基于地址的、基于 ID 的，在一些情况下还可以是隐式路由。TLP Header 中的路由子域（routing subfield），也就是 Byte 0 bit 2:0，它用来表示使用的是哪种路由方法，并且相应的在 Header 中定义了哪些附加的字段，例如使用基于 ID 路由的 Header 中就会有用于路由的 BDF。通用的 Message 请求 Header 格式如图 5‑11 所示。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image232.jpg" /></p>
<p>图 5‑11 4DW 的 Message 请求 Header 格式</p>
<h6 id="l-message-header-message-request-header-fields">l Message 请求 Header 各字段（Message Request Header Fields）<a class="headerlink" href="#l-message-header-message-request-header-fields" title="Permanent link">&para;</a></h6>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>位于 Header 中的 Byte/Bit</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fmt[2:0]  格式  （Format）</td>
<td>Byte  0 Bit 7:5</td>
<td>Message 始终为 4DW Header：  001b=4DW，无数据  <br>011b=4DW，有数据</td>
</tr>
<tr>
<td>Type[4:0]  类型</td>
<td>Byte  0 Bit 4:0</td>
<td>TLP 包的 Type 字段。 <br> Bit 4:3：  10b=Msg <br> Bit 2:0：（Message 路由子域）<br>000b=到 RC 的隐式路由。<br>001b=使用地址路由  <br/>010b=使用 ID 路由  <br/>011b=来自 RC 的隐式路由广播 <br/>100b=本地；终结于首级接收者  <br/>101b=收集并路由至 RC  其他值=保留值，作为本地处理</td>
</tr>
<tr>
<td>TC[2:0]  流量类型  （Traffic Class）</td>
<td>Byte  1 Bit 6:4</td>
<td>Message 的 TC 始终为 0，以确保它们不会影响到高优先级的数据包。</td>
</tr>
<tr>
<td>Attr[2]  属性  （Attribute）</td>
<td>Byte  1 Bit 2</td>
<td>表示这个 TLP 是否使用基于 ID 的排序（ID-based Ordering）。更多内容请参阅“ID Based Ordering（IDO）”一节。</td>
</tr>
<tr>
<td>TH  TLP 处理提示  （TLP Processing Hints）</td>
<td>Byte  1 Bit 0</td>
<td>Message 中，除非另有注明，此字段为保留字段。</td>
</tr>
<tr>
<td>TD  TLP 摘要  （TLP Digest）</td>
<td>Byte  2 Bit 7</td>
<td>如果为 1，则说明 TLP 的末尾存在 1DW 的 Digest 字段（在 LCRC 和 END 字符之前）。</td>
</tr>
<tr>
<td>EP  受污染的数据  （Poisoned Data）</td>
<td>Byte  2 Bit 6</td>
<td>如果为 1，则表示数据荷载是被污染的。</td>
</tr>
<tr>
<td>Attr[1:0]  属性  （Attribute）</td>
<td>Byte  2 Bit 5:4</td>
<td>Message 中，除非另有注明，此字段为保留字段。</td>
</tr>
<tr>
<td>AT[1:0]  地址类型  （Address Type）</td>
<td>Byte  2 Bit 3:2</td>
<td>Message 的 Address Type 字段为保留字段，必须为 0，但是并不要求甚至不鼓励接收方对这个字段进行检查。</td>
</tr>
<tr>
<td>Length[9:0]  长度</td>
<td>Byte  2 Bit 1:0  Byte  3 Bit 7:0</td>
<td>用于表示完成包数据荷载的大小，单位为 DW。对于 Message 来说，这个字段始终为 0（无数据）或 1（有 1DW 数据）。</td>
</tr>
<tr>
<td>Requester  ID[15:0]  Requester  ID</td>
<td>Byte  4 Bit 7:0  Byte  5 Bit 7:0</td>
<td>用于表示发送 Message 的 Requester 是谁。  Byte 4,7:0=Requester  Bus Number  Byte 5,7:3=Requester  Device Number  Byte 5,2:0=Requester  Function Number</td>
</tr>
<tr>
<td>Tag[7:0]  Tag</td>
<td>Byte  6 Bit 7:0</td>
<td>由于所有的 Message 请求都是 Posted 的，不需要 Requester 接收完成包，因此不需要给 Message 分配 Tag。这个字段应该为 0。</td>
</tr>
<tr>
<td>Message  Code[7:0]  Message 标识码</td>
<td>Byte  7 Bit 7:0</td>
<td>这个字段包含的标识码表示发送的 Message 是什么种类。 <br> 0000 0000b=解锁 Message（Unlock Message） <br> 0001 0000b=延迟容忍报告（Lat. Tolerance Reporting） <br> 0001 0010b=优化的 Buffer 刷新/填满（Optimized Buffer Flush/Fill） <br> 0001 xxxxb=电源管理 Message（Power Mgt. Message） <br> 0010 0xxxb=INTx Message <br> 0011 00xxb=错误 Message（Error Message） <br> 0100 xxxxb=忽略 Message（Ignored Message） <br> 0101 0000b=设置插槽功耗 Message（Set Slot Power Message） <br> 0111 111xb=厂商定义的 Message（Vendor Defined Message）</td>
</tr>
<tr>
<td>Address[63:32]  高 32bit 地址</td>
<td>Byte  8 Bit 7:0  Byte  9 Bit 7:0  Byte  10 Bit 7:0  Byte  11 Bit 7:0</td>
<td>如果 Message 选用了地址路由（见上面介绍的 Type[4:0]字段），那么这个字段的内容就是 64bit 起始地址的高 32bit。如果使用是 ID 路由，那么 Byte8-9 就组成目标 ID。  否则，这个字段就不使用。</td>
</tr>
<tr>
<td>Address[31:0]  低 32bit 地址</td>
<td>Byte  12 Bit 7:0  Byte  13 Bit 7:0  Byte  14 Bit 7:0  Byte  15 Bit 7:0</td>
<td>如果 Message 选用了地址路由（见上面介绍的 Type[4:0]字段），那么这个字段的内容就是 64bit 起始地址的低 32bit（最低的 2bit 必须为 0，以保持 DW 对齐）。  否则，这个字段就不使用。</td>
</tr>
</tbody>
</table>
<p>表 5‑8 Message 请求 Header 各字段</p>
<h6 id="l-message-using-the-byte-count-modified-bit">l Message 注意事项（Using The Byte Count Modified Bit）<a class="headerlink" href="#l-message-using-the-byte-count-modified-bit" title="Permanent link">&para;</a></h6>
<p>接下来几个小节的列表会列出 9 种 Message 组（如表 5‑8 中给出的）的各自使用的更具体的 Message Code。这 9 种 Message 组为：</p>
<ol>
<li>
<p>INTx 中断信号（INTx Interrupt Signaling）</p>
</li>
<li>
<p>电源管理（Power Management）</p>
</li>
<li>
<p>错误信号（Error Signaling）</p>
</li>
<li>
<p>支持锁定事务（Locked Transaction Support）</p>
</li>
<li>
<p>支持插槽功耗限制（Slot Power Limit Support）</p>
</li>
<li>
<p>厂商定义的 Message（Vendor-Defined Message）</p>
</li>
<li>
<p>忽略 Message（Ignored Message，与 PCIe 1.1 中的热插拔支持相关）</p>
</li>
<li>
<p>延迟容忍报告（Latency Tolerance Reporting，LTR）</p>
</li>
<li>
<p>优化的 Buffer 刷新和填满（Optimized Buffer Flush and Fill，OBFF）</p>
</li>
</ol>
<h6 id="l-intx-messageintx-interrupt-messages">l INTx 中断 Message（INTx Interrupt Messages）<a class="headerlink" href="#l-intx-messageintx-interrupt-messages" title="Permanent link">&para;</a></h6>
<p>许多设备都适用 PCI 2.3 的 MSI（Message Signaled Interrupt）方法来传输中断，但是对于老的设备来说可能会不支持 MSI。对于这些情况，PCIe 定义了一个“虚拟线 virtual wire”作为替代方案，设备通过发送 Message 来模拟 PCI 中断引脚（INTA-INTD）的拉起与释放。中断设备发出第一个 Message 来通知上行设备自己拉起了一个中断。一旦这个中断被响应处理（Serviced）了，那么中断设备就发出第二个 Message 来表示这个“虚拟中断线”已经释放。更多关于这种协议的内容，请参阅“Virtual INTx Signaling”一节。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image234.jpg" /></p>
<p>表 5‑9 INTx 中断信号 Message 的代码</p>
<p>关于使用 INTx Message 的一些规则：</p>
<ol>
<li>
<p>INTx Message 没有数据荷载，因此 Length 字段为保留字段。</p>
</li>
<li>
<p>它们只会由上行端口（Upstream Port）发出。对接收到的数据包进行这方面的规则检查是可选项，但是如果进行了检查，那么发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>INTx Message 需要使用默认的流量类型 TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>链路两端的组件必须跟踪四种虚拟中断（virtual interrupt）的状态。如果上行端口的一个中断的逻辑状态发生了改变，那么它必须发出相应的 INTx Message。</p>
</li>
<li>
<p>当命令寄存器（Command Register）中的 Interrupt Disable 位被置为 1 时，INTx 信号是被禁用的（就像物理中断线的类似情况一样）。</p>
</li>
<li>
<p>如果在 Interrupt Disable 位为 1 时，设备的任何一个虚拟 INTx 信号仍为激活状态，那么上行端口必须发出对应的释放 INTx Message（Deassert_INTx Message）。</p>
</li>
<li>
<p>Switch 的各个下行端口必须独立的跟踪四种 INTx 信号状态，并组合成上行端口的状态。</p>
</li>
<li>
<p>RC 的各个下行端口必须独立的跟踪下行端口的 INTx 信号状态，并将它们转换成系统中断，具体的转换方式根据具体实现而定。</p>
</li>
<li>
<p>INTx Message 使用“Local-Terminate at Receiver 在接收者本地结束”的路由类型来使得一个 Switch 在必要时对指定的中断引脚进行重映射（参阅“Mapping and Collapsing INTx Messages”一节）。因此，INTx Message 中的 Requester ID 有可能是最后一个传送者所指定的。</p>
</li>
</ol>
<h6 id="l-messagepower-management-messages">l 电源管理 Message（Power Management Messages）<a class="headerlink" href="#l-messagepower-management-messages" title="Permanent link">&para;</a></h6>
<p>PCIe 对 PCI 的电源管理是兼容的，并且还加入了基于硬件的链路电源管理。Message 是用来传达一些关于电源管理的信息，但是如果想了解完整的 PCIe 电源管理协议是如何工作的，那么请参阅 Chapter 16 “Power Management”一章。表 5‑10 总结了四种电源管理 Message 类型。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image236.jpg" /></p>
<p>表 5‑10 电源管理 Message 标识码</p>
<p>关于使用电源管理 Message 的一些规则：</p>
<ol>
<li>
<p>电源管理 Message 没有数据荷载，因此 Length 字段为保留字段。</p>
</li>
<li>
<p>电源管理 Message 需要使用默认的流量类型 TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>当一个下行端口收到了一个链路对端电源管理请求，请求要将链路电源状态更改为 L1，但是下行端口拒绝这种更改，那么它就要发出 PM_Active_State_Nak 这种电源管理 Message。</p>
</li>
<li>
<p>当一个组件请求电源管理事件（Power Management Event）时，它的上行端口需要发出 PM_PME，这个 Message 将被隐式路由至 RC。</p>
</li>
<li>
<p>PM_Turn_Off 会向下发送给所有的 EP（由 RC 发出，进行隐式路由的广播）。</p>
</li>
<li>
<p>PME_TO_Ack 是由 EP 的上行端口发出的。对于拥有多个下行端口的 Switch 来说，只有当所有的下行端口都收到了这个 Message，才会将其转发至上行（也就是汇聚收集，并路由转发给 RC）。</p>
</li>
</ol>
<h6 id="l-messageerror-messages">l 错误 Message（Error Messages）<a class="headerlink" href="#l-messageerror-messages" title="Permanent link">&para;</a></h6>
<p>当启用了错误 Message 的组件检测到了错误，那么就会将错误 Message 向上发送（隐式路由至 RC）。为了协助软件，让软件知道应该如何处理这个错误，在 Error Message 中使用 Header 中的 Requester ID 字段来表示请求者。表 5‑11 总结了三种 Error Message 类型。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image238.jpg" /></p>
<p>表 5‑11 错误 Message 标识码</p>
<p>关于使用 Error Message 的一些规则：</p>
<ol>
<li>
<p>Error Message 没有数据荷载，因此 Length 字段为保留字段。</p>
</li>
<li>
<p>Error Message 需要使用默认的流量类型 TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>RC 会将 Error Message 转换成系统指定的事件。</p>
</li>
</ol>
<h6 id="l-locked-transaction-support">l 支持锁定事务（Locked Transaction Support）<a class="headerlink" href="#l-locked-transaction-support" title="Permanent link">&para;</a></h6>
<p>解锁 Message（Unlock Message）被应用于 PCI 定义的锁定事务协议中（Locked Transaction Protocol），并且在 PCIe 中依然对传统 PCI 遗留设备可用。这种协议起始于一个 MRd Lock 请求。当这个请求在被送达到目标设备的过程中，沿途的端口们都会发现它，这些端口会实现一个原子“读-修改-写”协议（read-modify-write protocol），也就是说它们将会锁定 VC0（Virtual Channel 0）让其他的请求不能使用，直到收到 Unlock Message 才会对 VC0 解锁。这种 Unlock Message 会被发送至 Locked 事务的目标设备，以此来释放传输路径中的所有被锁定的端口，并用于最终完成锁定事务的一系列行为。表 5‑12 总结了 Unlock Message 的标识码。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image240.jpg" /></p>
<p>表 5‑12 解锁 Message 标识码</p>
<p>关于使用 Unlock Message 的一些规则：</p>
<ol>
<li>
<p>Unlock Message 没有数据荷载，因此 Length 字段为保留字段。</p>
</li>
<li>
<p>Unlock Message 需要使用默认的流量类型 TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
</ol>
<h6 id="l-messageset-slot-power-limit-message">l 设置插槽功率限制 Message（Set Slot Power Limit Message）<a class="headerlink" href="#l-messageset-slot-power-limit-message" title="Permanent link">&para;</a></h6>
<p>这种 Message 是由下行端口发送给插在插槽上的设备的。这里面的功率限制信息会储存在 EP 的设备能力寄存器中（Device Capabilities Register）。表 5‑12 总结了 Unlock Message 的标识码。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image242.jpg" /></p>
<p>表 5‑13 插槽功率限制 Message 标识码</p>
<p>关于使用 Set Slot Power Limit Message 的一些规则：</p>
<ol>
<li>
<p>Set Slot Power Limit Message 需要使用默认的流量类型 TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形 TLP（Malformed TLP）。</p>
</li>
<li>
<p>Set Slot Power Limit Message 的数据荷载为 1DW，因此 Length 字段的值为 1。而在 32bit 数据荷载中仅有低 10bit 用于进行插槽功率放大或减小；剩下的高位必须都置为 0。</p>
</li>
<li>
<p>当数据链路层转换为 DL-Up 状态时，该消息会自动发送。或者是放数据链路层已经报告了 DL-Up 状态，然后发生了一个配置写来写入 Slot Capabilities Register 时，该消息也会自动发送。</p>
</li>
<li>
<p>如果插槽中的板卡消耗的功率已经低于了指定的功率限制，那么可以忽略这种 Message。</p>
</li>
</ol>
<h6 id="l-message-0-1vendor-defined-message-0-and-1">l 厂商定义的 Message 0 和 1（Vendor-Defined Message 0 and 1）<a class="headerlink" href="#l-message-0-1vendor-defined-message-0-and-1" title="Permanent link">&para;</a></h6>
<p>Vendor-Defined Message 是用于进行 PCIe Message 能力的扩展，这种扩展既可以通过协议本身，也可以通过厂商来指定的扩展。这种 Message 的 Header 格式如图 5‑12 所示，Message 标识码如表 5‑12。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image244.jpg" /></p>
<p>图 5‑12 厂商定义的 Message Header 格式</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image246.jpg" /></p>
<p>表 5‑14 厂商定义的 Message 标识码</p>
<p>关于使用Vendor-Defined Message 的一些规则：</p>
<ol>
<li>
<p>Vendor-Defined Message 0 和1 可以有也可以没有数据荷载。</p>
</li>
<li>
<p>Message 用Vendor ID 来进行区分。</p>
</li>
<li>
<p>Attr[2]和Attr[1:0]并不是保留位。</p>
</li>
<li>
<p>如果接收者无法认出这种Message：</p>
<ul>
<li>
<p>Type 1 Message 可以被安静的忽略丢弃掉。</p>
</li>
<li>
<p>Type 0 Message 要被作为Unsupported Request（UR）这种错误情况来处理。</p>
</li>
</ul>
</li>
</ol>
<h6 id="l-messageignored-message">l 被忽略的Message（Ignored Message）<a class="headerlink" href="#l-messageignored-message" title="Permanent link">&para;</a></h6>
<p>如果直接列出一整个目录的需要被忽略的Message，而不去讲忽略的前因后果，那可能会听起来有一些奇怪。这些Message 其实是原来的热插拔信号Message（Hot Plug Signaling Message），它们用于支持设备，这些设备上具有热插拔指示器，并且只需要按下这个插卡设备上的按钮而不是系统板上的按钮。这种Message 类型是由PCIe 1.0a 版本所定义的，但是这个选项在PCIe 1.1 版本中就已经不再支持了，因此这里所讲的这些细节内容仅作为参考。正如名字要表达的那样，强烈建议发送方不要发送这些Message，并且也强烈建议接收方就算收到它们也要忽视掉。如果无论如何仍要使用这些Message，那么它们必须要符合PCIe 1.0a 的协议细节。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image248.jpg" /></p>
<p>表 5‑15 热插拔Message 标识码</p>
<p>关于使用Hot Plug Message 的一些规则：</p>
<ol>
<li>
<p>Hot Plug Message 由下行端口发送给插槽中的板卡。</p>
</li>
<li>
<p>Attention_Button Message 是由插槽中的设备向上行发送的。</p>
</li>
</ol>
<h6 id="l-messagelatency-tolerance-reporting-message">l 延迟容忍报告Message（Latency Tolerance Reporting Message）<a class="headerlink" href="#l-messagelatency-tolerance-reporting-message" title="Permanent link">&para;</a></h6>
<p>LTR Message 是用来报告一个设备可接受的读写服务延迟，这是一个可选项。更多关于这种电源管理技术的内容，请参阅“LTR（Latency Tolerance Reporting）”一节。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image250.jpg" /></p>
<p>图 5‑13 LTR Message Header 格式</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image252.jpg" /></p>
<p>表 5‑16 LTR Message 标识码</p>
<p>关于使用LTR Message 的一些规则：</p>
<ol>
<li>
<p>LTR Message 没有数据荷载，因此Length 字段为保留字段。</p>
</li>
<li>
<p>LTR Message 需要使用默认的流量类型TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形TLP（Malformed TLP）。</p>
</li>
</ol>
<h6 id="l-buffer-messageoptimized-buffer-flush-and-fill">l 优化的Buffer 刷新和填充Message（Optimized Buffer Flush and Fill）<a class="headerlink" href="#l-buffer-messageoptimized-buffer-flush-and-fill" title="Permanent link">&para;</a></h6>
<p>OBFF Message 用来向EP 报告平台电源情况，以此来促进更高效的系统电源管理。更多关于这种技术的内容，请参阅“OBBF（Optimized Buffer Flush and Fill）”一节。</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image254.jpg" /></p>
<p>图 5‑14 OBBF Message Header 格式</p>
<p><img alt="img" src="../img/5%20TLP%20%E5%85%83%E7%B4%A0/clip_image256.jpg" /></p>
<p>表 5‑17 OBBF Message 标识码</p>
<p>关于使用OBFF Message 的一些规则：</p>
<ol>
<li>
<p>OBFF Message 没有数据荷载，因此Length 字段为保留字段。</p>
</li>
<li>
<p>OBFF Message 需要使用默认的流量类型TC 0。接收方必须检查这一条规则，发现违例的数据包就会被当做畸形TLP（Malformed TLP）。</p>
</li>
<li>
<p>Header 中的Requester ID 必须为传送中的端口的ID。</p>
</li>
</ol>
<hr />
<p>原文：  Mindshare</p>
<p>译者：  Michael ZZY</p>
<p>校对：  </p>
<p>欢迎参与 《Mindshare PCI Express Technology 3.0 一书的中文翻译计划》</p>
<p><a href="https://gitee.com/ljgibbs/chinese-translation-of-pci-express-technology">https://gitee.com/ljgibbs/chinese-translation-of-pci-express-technology</a></p>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../04%20%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BA%8B%E5%8A%A1%E8%B7%AF%E7%94%B1/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 04 地址空间与事务路由">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                04 地址空间与事务路由
              </div>
            </div>
          </a>
        
        
          
          <a href="../06%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="md-footer__link md-footer__link--next" aria-label="下一页: 06 流量控制">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                06 流量控制
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2022-2023 杰森
    </div>
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "content.code.copy", "navigation.expand", "navigation.footer", "navigation.indexes", "navigation.tracking", "navigation.top", "navigation.path", "toc.follow", "toc.integrate", "search.suggest", "search.highlight"], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
    
  </body>
</html>